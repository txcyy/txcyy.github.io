3:I[9275,[],""]
6:I[1343,[],""]
7:I[9512,["257","static/chunks/257-d6408e43d3a4c1f7.js","231","static/chunks/231-75c2bb16e5311c25.js","185","static/chunks/app/layout-5aac403eda8ffac1.js"],"ThemeProvider"]
8:I[9890,["257","static/chunks/257-d6408e43d3a4c1f7.js","231","static/chunks/231-75c2bb16e5311c25.js","185","static/chunks/app/layout-5aac403eda8ffac1.js"],"ColorProvider"]
9:I[1998,["257","static/chunks/257-d6408e43d3a4c1f7.js","231","static/chunks/231-75c2bb16e5311c25.js","185","static/chunks/app/layout-5aac403eda8ffac1.js"],"default"]
a:I[3408,["257","static/chunks/257-d6408e43d3a4c1f7.js","231","static/chunks/231-75c2bb16e5311c25.js","185","static/chunks/app/layout-5aac403eda8ffac1.js"],"ColorToggle"]
b:I[6345,["257","static/chunks/257-d6408e43d3a4c1f7.js","231","static/chunks/231-75c2bb16e5311c25.js","185","static/chunks/app/layout-5aac403eda8ffac1.js"],"ThemeToggle"]
c:I[7970,["257","static/chunks/257-d6408e43d3a4c1f7.js","231","static/chunks/231-75c2bb16e5311c25.js","185","static/chunks/app/layout-5aac403eda8ffac1.js"],"NavToggle"]
4:["category","web--react","d"]
5:["title","react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB","d"]
0:["GB6GWdwB48S_6jQAbWqVr",[[["",{"children":["post",{"children":[["category","web--react","d"],{"children":[["title","react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB","d"],{"children":["__PAGE__?{\"category\":\"web--react\",\"title\":\"react源码阅读\"}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["post",{"children":[["category","web--react","d"],{"children":[["title","react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB","d"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","post","children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2715c8fee6b9b9b3.css","precedence":"next","crossOrigin":"$undefined"}]]}],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","post","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","post","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"min-h-screen bg-background font-sans antialiased __variable_aaf875","children":["$","$L7",null,{"attribute":"class","defaultTheme":"system","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$L8",null,{"children":[["$","header",null,{"className":"sticky top-0 z-50 w-full border-b border-primary/40 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60","children":["$","div",null,{"className":"container flex h-14 max-w-screen-2xl items-center justify-between","children":[["$","div",null,{"className":"mr-4 flex","children":[["$","a",null,{"className":"mr-6 flex items-center space-x-2","href":"/","children":[["$","span",null,{"className":"inline-block w-8 h-8","children":["$","svg",null,{"viewBox":"0 0 64 64","children":["$","g",null,{"fill":"none","fillRule":"evenodd","children":[["$","circle",null,{"cx":32,"cy":32,"r":26,"fill":"hsl(var(--primary))"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","xmlnsXlink":"http://www.w3.org/1999/xlink","width":26,"height":26,"x":19,"y":10,"viewBox":"0 0 24 24","children":["$","path",null,{"fill":"hsl(var(--background))","d":"M5.438 2c-.512 0-1.02.203-1.407.594L2.594 4.03a1.987 1.987 0 0 0 0 2.813l2.125 2.125C3.977 10.46 3.207 12.016 3 12.375c-.469.813-1 1.617-1 2.625 0 1.473.805 2.746 2 3.438.184.105 4.188 2.906 4.188 2.906h.03C8.896 21.75 9.66 22 10.5 22h3c.832 0 1.613-.223 2.281-.625.38-.227 4.031-2.664 5.219-3.75.688-.633 1-1.621 1-2.625s-.414-1.754-1-2.625c-.277-.43-1.023-1.96-1.719-3.406l2.125-2.125a1.987 1.987 0 0 0 0-2.813L19.97 2.594a1.987 1.987 0 0 0-2.813 0l-1.5 1.5A2.2 2.2 0 0 0 15 4H9a2.8 2.8 0 0 0-.656.094l-1.5-1.5A1.98 1.98 0 0 0 5.437 2M9.5 10a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3m5 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3M12 13.813c.395 0 .79.054 1 .187.95.59 3 2.883 3 4 0 .559-1.328 1.781-2 2-.953.309-3.047.309-4 0-.672-.219-2-1.441-2-2 0-1.117 2.05-3.41 3-4 .21-.133.605-.187 1-.187M11 17c-.363 0-.57.43-.312.688l1.03 1.218c.16.16.403.16.563 0l1.031-1.218C13.57 17.43 13.364 17 13 17Z"}]}],["$","text",null,{"fill":"hsl(var(--background))","data-text-alignment":"C","fontFamily":"Fira Mono","fontSize":14,"fontWeight":700,"letterSpacing":0.81,"transform":"translate(-4 33)","children":["$","tspan",null,{"x":17.07,"y":17,"children":"XCYY"}]}],["$","circle",null,{"cx":32,"cy":32,"r":30,"stroke":"hsl(var(--primary))","strokeWidth":2}]]}]}]}],["$","span",null,{"className":"text-primary","children":"新宸悦雨"}]]}],["$","$L9",null,{}]]}],["$","nav",null,{"className":"flex items-center space-x-2","children":[["$","$La",null,{}],["$","$Lb",null,{}],["$","div",null,{"className":"md:hidden","children":["$","$Lc",null,{}]}]]}]]}]}],["$","main",null,{"className":"container max-w-screen-2xl py-6","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}]]}]}]}]}],null],null],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f8ad259a7d5c0bf2.css","precedence":"next","crossOrigin":"$undefined"}]],"$Ld"]]]]
e:I[789,["257","static/chunks/257-d6408e43d3a4c1f7.js","472","static/chunks/app/post/%5Bcategory%5D/%5Btitle%5D/page-bb1b5c27d30bc491.js"],"default"]
f:T1568,
<ul>
<li><a href="#react%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89">React数据结构定义</a>
<ul>
<li><a href="#reactfiberroot">ReactFiberRoot</a></li>
<li><a href="#reactfiber">ReactFiber</a></li>
<li><a href="#update">Update</a></li>
<li><a href="#updatequeue">UpdateQueue</a></li>
</ul>
</li>
<li><a href="#react%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89">React类型/常量定义</a>
<ul>
<li><a href="#reactroottagsjs">ReactRootTags.js</a></li>
<li><a href="#reactfiberexpirationtimejs">ReactFiberExpirationTime.js</a></li>
<li><a href="#schedulerwithreactintegrationjs">SchedulerWithReactIntegration.js</a></li>
<li><a href="#reactworktagsjs">ReactWorkTags.js</a></li>
<li><a href="#reactsideeffecttagsjs">ReactSideEffectTags.js</a></li>
<li><a href="#reacttypeofmodejs">ReactTypeOfMode.js</a></li>
<li><a href="#reactfiberworkloopjs">ReactFiberWorkLoop.js</a></li>
<li><a href="#reactsharedinternalsjs">ReactSharedInternals.js</a></li>
</ul>
</li>
<li><a href="#reactdomrender%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">ReactDOM.render调用过程</a>
<ul>
<li><a href="#reactdomrender">ReactDOM.render</a></li>
<li><a href="#legacyrendersubtreeintocontainer">legacyRenderSubtreeIntoContainer</a>
<ul>
<li><a href="#root%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B">root创建过程</a>
<ul>
<li><a href="#legacycreaterootfromdomcontainer">legacyCreateRootFromDOMContainer</a></li>
<li><a href="#new-reactsyncroot">new ReactSyncRoot</a></li>
<li><a href="#createrootimpl">createRootImpl</a>
<ul>
<li><a href="#createcontainer">createContainer</a>
<ul>
<li><a href="#createfiberroot">createFiberRoot</a></li>
<li><a href="#new-fiberrootnode">new FiberRootNode</a></li>
<li><a href="#createhostrootfiber">createHostRootFiber</a></li>
<li><a href="#createfiber">createFiber</a></li>
<li><a href="#new-fibernode">new FiberNode</a></li>
</ul>
</li>
<li><a href="#markcontainerasroot">markContainerAsRoot</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#callback%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">callback调用过程</a>
<ul>
<li><a href="#getpublicrootinstance">getPublicRootInstance</a></li>
</ul>
</li>
<li><a href="#updatecontainer%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">updateContainer调用过程</a>
<ul>
<li><a href="#unbatchedupdates">unbatchedUpdates</a></li>
<li><a href="#updatecontainer">updateContainer</a>
<ul>
<li><a href="#requestcurrenttime">requestCurrentTime</a></li>
<li><a href="#mstoexpirationtime">msToExpirationTime</a></li>
<li><a href="#requestcurrentsuspenseconfig">requestCurrentSuspenseConfig</a></li>
<li><a href="#computeexpirationforfiber">computeExpirationForFiber</a></li>
</ul>
</li>
<li><a href="#updatecontaineratexpirationtime">updateContainerAtExpirationTime</a>
<ul>
<li><a href="#getcontextforsubtree">getContextForSubtree</a></li>
<li><a href="#findcurrentunmaskedcontext">findCurrentUnmaskedContext</a></li>
</ul>
</li>
<li><a href="#schedulerootupdate">scheduleRootUpdate</a>
<ul>
<li><a href="#createupdate">createUpdate</a></li>
<li><a href="#enqueueupdate">enqueueUpdate</a>
<ul>
<li><a href="#createupdatequeue">createUpdateQueue</a></li>
<li><a href="#cloneupdatequeue">cloneUpdateQueue</a></li>
<li><a href="#appendupdatetoqueue">appendUpdateToQueue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#schedulework">scheduleWork</a>
<ul>
<li>
<ul>
<li><a href="#checkfornestedupdates">checkForNestedUpdates</a></li>
<li><a href="#markupdatetimefromfibertoroot">markUpdateTimeFromFiberToRoot</a></li>
<li><a href="#checkforinterruption">checkForInterruption</a></li>
<li><a href="#recordscheduleupdate">recordScheduleUpdate</a></li>
<li><a href="#getcurrentprioritylevel">getCurrentPriorityLevel</a></li>
<li><a href="#schedulependinginteractions">schedulePendingInteractions</a></li>
<li><a href="#performsyncworkonroot">performSyncWorkOnRoot</a></li>
</ul>
</li>
<li><a href="#preparefreshstack">prepareFreshStack</a>
<ul>
<li><a href="#createworkinprogress">createWorkInProgress</a></li>
<li><a href="#pushdispatcher">pushDispatcher</a></li>
<li><a href="#workloopsync">workLoopSync</a></li>
<li><a href="#performunitofwork">performUnitOfWork</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beginwork">beginWork</a>
<ul>
<li><a href="#updatehostroot">updateHostRoot</a>
<ul>
<li><a href="#pushhostrootcontext">pushHostRootContext</a></li>
<li><a href="#pushtoplevelcontextobject">pushTopLevelContextObject</a></li>
<li><a href="#push">push</a></li>
<li><a href="#pushhostcontainer">pushHostContainer</a></li>
</ul>
</li>
<li><a href="#processupdatequeue">processUpdateQueue</a>
<ul>
<li><a href="#getstatefromupdate">getStateFromUpdate</a></li>
</ul>
</li>
<li><a href="#reconcilechildren">reconcileChildren</a></li>
<li><a href="#reconcilechildfibers">reconcileChildFibers</a></li>
<li><a href="#reconcilesingleelement">reconcileSingleElement</a>
<ul>
<li><a href="#createfiberfromelement">createFiberFromElement</a></li>
<li><a href="#"></a></li>
</ul>
</li>
<li><a href="#placesinglechild">placeSingleChild</a></li>
<li><a href="#completeunitofwork">completeUnitOfWork</a></li>
</ul>
</li>
<li><a href="#completework">completeWork</a>
<ul>
<li>
<ul>
<li><a href="#pophostcontainer">popHostContainer</a></li>
<li><a href="#poptoplevellegacycontextobject">popTopLevelLegacyContextObject</a></li>
<li><a href="#popdispatcher">popDispatcher</a></li>
</ul>
</li>
<li><a href="#finishsyncrender">finishSyncRender</a></li>
<li><a href="#commitroot">commitRoot</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>10:T55a88,
<h1 id="react数据结构定义">React数据结构定义</h1>
<h2 id="reactfiberroot">ReactFiberRoot</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberRoot.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberRootNode</span>(<span class="hljs-params">containerInfo, tag, hydrate</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">containerInfo</span> = containerInfo;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingChildren</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pingCache</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">finishedExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">finishedWork</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timeoutHandle</span> = noTimeout;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingContext</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">hydrate</span> = hydrate;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstBatch</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// NoPriority 详见React类型/常量定义-SchedulerWithReactIntegration.js</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoPriority</span>;
  <span class="hljs-comment">// NoWork 详见React类型/常量定义-ReactFiberExpirationTime.js</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstPendingTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstSuspendedTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastSuspendedTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextKnownPendingLevel</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastPingedTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastExpiredTime</span> = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interactionThreadID</span> = <span class="hljs-title function_">unstable_getThreadID</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedInteractions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingInteractionMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  }
  <span class="hljs-keyword">if</span> (enableSuspenseCallback) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hydrationCallbacks</span> = <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h2 id="reactfiber">ReactFiber</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiber.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params">
  tag: WorkTag,
  pendingProps: mixed,
  key: <span class="hljs-literal">null</span> | string,
  mode: TypeOfMode,
</span>) {
  <span class="hljs-comment">// Instance</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementType</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// Fiber</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode;

  <span class="hljs-comment">// Effects</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">NoEffect</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">expirationTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (enableProfilerTimer) {
    <span class="hljs-comment">// Note: The following is done to avoid a v8 performance cliff.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Initializing the fields below to smis and later updating them with</span>
    <span class="hljs-comment">// double values will cause Fibers to end up having separate shapes.</span>
    <span class="hljs-comment">// This behavior/bug has something to do with Object.preventExtension().</span>
    <span class="hljs-comment">// Fortunately this only impacts DEV builds.</span>
    <span class="hljs-comment">// Unfortunately it makes React unusably slow for some applications.</span>
    <span class="hljs-comment">// To work around this, initialize the fields below with doubles.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Learn more about this here:</span>
    <span class="hljs-comment">// https://github.com/facebook/react/issues/14365</span>
    <span class="hljs-comment">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;

    <span class="hljs-comment">// It's okay to replace the initial doubles with smis after initialization.</span>
    <span class="hljs-comment">// This won't trigger the performance cliff mentioned above,</span>
    <span class="hljs-comment">// and it simplifies other profiler code (including DevTools).</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// This is normally DEV-only except www when it adds listeners.</span>
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> remove the User Timing integration in favor of Root Events.</span>
  <span class="hljs-keyword">if</span> (enableUserTimingAPI) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugID</span> = debugCounter++;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugIsCurrentlyTiming</span> = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">if</span> (__DEV__) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugSource</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugOwner</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugNeedsRemount</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugHookTypes</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (!hasBadMapPolyfill &#x26;&#x26; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">preventExtensions</span> === <span class="hljs-string">'function'</span>) {
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(<span class="hljs-variable language_">this</span>);
    }
  }
}
</code></pre>
<h2 id="update">Update</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createUpdate</span>(<span class="hljs-params">
  expirationTime: ExpirationTime,
  suspenseConfig: <span class="hljs-literal">null</span> | SuspenseConfig,
</span>): <span class="hljs-title class_">Update</span>&#x3C;*> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">update</span>: <span class="hljs-title class_">Update</span>&#x3C;*> = {
    expirationTime,
    suspenseConfig,

    <span class="hljs-attr">tag</span>: <span class="hljs-title class_">UpdateState</span>,
    <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,

    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">nextEffect</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-keyword">if</span> (__DEV__) {
    update.<span class="hljs-property">priority</span> = <span class="hljs-title function_">getCurrentPriorityLevel</span>();
  }
  <span class="hljs-keyword">return</span> update;
}
</code></pre>
<h2 id="updatequeue">UpdateQueue</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> createUpdateQueue&#x3C;<span class="hljs-title class_">State</span>>(<span class="hljs-attr">baseState</span>: <span class="hljs-title class_">State</span>): <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>> = {
    baseState,
    <span class="hljs-attr">firstUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">firstCapturedUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastCapturedUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">firstEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">firstCapturedEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastCapturedEffect</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-keyword">return</span> queue;
}
</code></pre>
<h1 id="react类型常量定义">React类型/常量定义</h1>
<h2 id="reactroottagsjs">ReactRootTags.js</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\shared\ReactRootTags.js</span>
<span class="hljs-keyword">export</span> type <span class="hljs-title class_">RootTag</span> = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LegacyRoot</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">BatchedRoot</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ConcurrentRoot</span> = <span class="hljs-number">2</span>;
</code></pre>
<h2 id="reactfiberexpirationtimejs">ReactFiberExpirationTime.js</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberExpirationTime.js</span>

<span class="hljs-keyword">import</span> type {<span class="hljs-title class_">ReactPriorityLevel</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'./SchedulerWithReactIntegration'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">MAX_SIGNED_31_BIT_INT</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./maxSigned31BitInt'</span>;

<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">ImmediatePriority</span>,
  <span class="hljs-title class_">UserBlockingPriority</span>,
  <span class="hljs-title class_">NormalPriority</span>,
  <span class="hljs-title class_">IdlePriority</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./SchedulerWithReactIntegration'</span>;

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">ExpirationTime</span> = number;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoWork</span> = <span class="hljs-number">0</span>;
<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think of a better name for Never. The key difference with Idle is that</span>
<span class="hljs-comment">// Never work can be committed in an inconsistent state without tearing the UI.</span>
<span class="hljs-comment">// The main example is offscreen content, like a hidden subtree. So one possible</span>
<span class="hljs-comment">// name is Offscreen. However, it also includes dehydrated Suspense boundaries,</span>
<span class="hljs-comment">// which are inconsistent in the sense that they haven't finished yet, but</span>
<span class="hljs-comment">// aren't visibly inconsistent because the server rendered HTML matches what the</span>
<span class="hljs-comment">// hydrated tree would look like.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Never</span> = <span class="hljs-number">1</span>;
<span class="hljs-comment">// Idle is slightly higher priority than Never. It must completely finish in</span>
<span class="hljs-comment">// order to be consistent.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Idle</span> = <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Sync</span> = <span class="hljs-variable constant_">MAX_SIGNED_31_BIT_INT</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Batched</span> = <span class="hljs-title class_">Sync</span> - <span class="hljs-number">1</span>;

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">UNIT_SIZE</span> = <span class="hljs-number">10</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAGIC_NUMBER_OFFSET</span> = <span class="hljs-title class_">Batched</span> - <span class="hljs-number">1</span>;

<span class="hljs-comment">// 1 unit of expiration time represents 10ms.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">msToExpirationTime</span>(<span class="hljs-params">ms: number</span>): <span class="hljs-title class_">ExpirationTime</span> {
  <span class="hljs-comment">// Always add an offset so that we don't clash with the magic number for NoWork.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">MAGIC_NUMBER_OFFSET</span> - ((ms / <span class="hljs-variable constant_">UNIT_SIZE</span>) | <span class="hljs-number">0</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">expirationTimeToMs</span>(<span class="hljs-params">expirationTime: ExpirationTime</span>): number {
  <span class="hljs-keyword">return</span> (<span class="hljs-variable constant_">MAGIC_NUMBER_OFFSET</span> - expirationTime) * <span class="hljs-variable constant_">UNIT_SIZE</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ceiling</span>(<span class="hljs-params">num: number, precision: number</span>): number {
  <span class="hljs-keyword">return</span> (((num / precision) | <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>) * precision;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">computeExpirationBucket</span>(<span class="hljs-params">
  currentTime,
  expirationInMs,
  bucketSizeMs,
</span>): <span class="hljs-title class_">ExpirationTime</span> {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-variable constant_">MAGIC_NUMBER_OFFSET</span> -
    <span class="hljs-title function_">ceiling</span>(
      <span class="hljs-variable constant_">MAGIC_NUMBER_OFFSET</span> - currentTime + expirationInMs / <span class="hljs-variable constant_">UNIT_SIZE</span>,
      bucketSizeMs / <span class="hljs-variable constant_">UNIT_SIZE</span>,
    )
  );
}

<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This corresponds to Scheduler's NormalPriority, not LowPriority. Update</span>
<span class="hljs-comment">// the names to reflect.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LOW_PRIORITY_EXPIRATION</span> = <span class="hljs-number">5000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LOW_PRIORITY_BATCH_SIZE</span> = <span class="hljs-number">250</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computeAsyncExpiration</span>(<span class="hljs-params">
  currentTime: ExpirationTime,
</span>): <span class="hljs-title class_">ExpirationTime</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">computeExpirationBucket</span>(
    currentTime,
    <span class="hljs-variable constant_">LOW_PRIORITY_EXPIRATION</span>,
    <span class="hljs-variable constant_">LOW_PRIORITY_BATCH_SIZE</span>,
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computeSuspenseExpiration</span>(<span class="hljs-params">
  currentTime: ExpirationTime,
  timeoutMs: number,
</span>): <span class="hljs-title class_">ExpirationTime</span> {
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Should we warn if timeoutMs is lower than the normal pri expiration time?</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">computeExpirationBucket</span>(
    currentTime,
    timeoutMs,
    <span class="hljs-variable constant_">LOW_PRIORITY_BATCH_SIZE</span>,
  );
}

<span class="hljs-comment">// We intentionally set a higher expiration time for interactive updates in</span>
<span class="hljs-comment">// dev than in production.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If the main thread is being blocked so long that you hit the expiration,</span>
<span class="hljs-comment">// it's a problem that could be solved with better scheduling.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// People will be more likely to notice this and fix it with the long</span>
<span class="hljs-comment">// expiration time in development.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In production we opt for better UX at the risk of masking scheduling</span>
<span class="hljs-comment">// problems, by expiring fast.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">HIGH_PRIORITY_EXPIRATION</span> = __DEV__ ? <span class="hljs-number">500</span> : <span class="hljs-number">150</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">HIGH_PRIORITY_BATCH_SIZE</span> = <span class="hljs-number">100</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computeInteractiveExpiration</span>(<span class="hljs-params">currentTime: ExpirationTime</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">computeExpirationBucket</span>(
    currentTime,
    <span class="hljs-variable constant_">HIGH_PRIORITY_EXPIRATION</span>,
    <span class="hljs-variable constant_">HIGH_PRIORITY_BATCH_SIZE</span>,
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inferPriorityFromExpirationTime</span>(<span class="hljs-params">
  currentTime: ExpirationTime,
  expirationTime: ExpirationTime,
</span>): <span class="hljs-title class_">ReactPriorityLevel</span> {
  <span class="hljs-keyword">if</span> (expirationTime === <span class="hljs-title class_">Sync</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ImmediatePriority</span>;
  }
  <span class="hljs-keyword">if</span> (expirationTime === <span class="hljs-title class_">Never</span> || expirationTime === <span class="hljs-title class_">Idle</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdlePriority</span>;
  }
  <span class="hljs-keyword">const</span> msUntil =
    <span class="hljs-title function_">expirationTimeToMs</span>(expirationTime) - <span class="hljs-title function_">expirationTimeToMs</span>(currentTime);
  <span class="hljs-keyword">if</span> (msUntil &#x3C;= <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ImmediatePriority</span>;
  }
  <span class="hljs-keyword">if</span> (msUntil &#x3C;= <span class="hljs-variable constant_">HIGH_PRIORITY_EXPIRATION</span> + <span class="hljs-variable constant_">HIGH_PRIORITY_BATCH_SIZE</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserBlockingPriority</span>;
  }
  <span class="hljs-keyword">if</span> (msUntil &#x3C;= <span class="hljs-variable constant_">LOW_PRIORITY_EXPIRATION</span> + <span class="hljs-variable constant_">LOW_PRIORITY_BATCH_SIZE</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NormalPriority</span>;
  }

  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Handle LowPriority</span>

  <span class="hljs-comment">// Assume anything lower has idle priority</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdlePriority</span>;
}

</code></pre>
<h2 id="schedulerwithreactintegrationjs">SchedulerWithReactIntegration.js</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\SchedulerWithReactIntegration.js</span>
<span class="hljs-comment">/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * <span class="hljs-doctag">@flow</span>
 */</span>

<span class="hljs-comment">// Intentionally not named imports because Rollup would use dynamic dispatch for</span>
<span class="hljs-comment">// CommonJS interop named imports.</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Scheduler</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'scheduler'</span>;
<span class="hljs-keyword">import</span> {__interactionsRef} <span class="hljs-keyword">from</span> <span class="hljs-string">'scheduler/tracing'</span>;
<span class="hljs-keyword">import</span> {enableSchedulerTracing} <span class="hljs-keyword">from</span> <span class="hljs-string">'shared/ReactFeatureFlags'</span>;
<span class="hljs-keyword">import</span> invariant <span class="hljs-keyword">from</span> <span class="hljs-string">'shared/invariant'</span>;

<span class="hljs-keyword">const</span> {
  <span class="hljs-attr">unstable_runWithPriority</span>: <span class="hljs-title class_">Scheduler</span>_runWithPriority,
  <span class="hljs-attr">unstable_scheduleCallback</span>: <span class="hljs-title class_">Scheduler</span>_scheduleCallback,
  <span class="hljs-attr">unstable_cancelCallback</span>: <span class="hljs-title class_">Scheduler</span>_cancelCallback,
  <span class="hljs-attr">unstable_shouldYield</span>: <span class="hljs-title class_">Scheduler</span>_shouldYield,
  <span class="hljs-attr">unstable_requestPaint</span>: <span class="hljs-title class_">Scheduler</span>_requestPaint,
  <span class="hljs-attr">unstable_now</span>: <span class="hljs-title class_">Scheduler</span>_now,
  <span class="hljs-attr">unstable_getCurrentPriorityLevel</span>: <span class="hljs-title class_">Scheduler</span>_getCurrentPriorityLevel,
  <span class="hljs-attr">unstable_ImmediatePriority</span>: <span class="hljs-title class_">Scheduler</span>_ImmediatePriority,
  <span class="hljs-attr">unstable_UserBlockingPriority</span>: <span class="hljs-title class_">Scheduler</span>_UserBlockingPriority,
  <span class="hljs-attr">unstable_NormalPriority</span>: <span class="hljs-title class_">Scheduler</span>_NormalPriority,
  <span class="hljs-attr">unstable_LowPriority</span>: <span class="hljs-title class_">Scheduler</span>_LowPriority,
  <span class="hljs-attr">unstable_IdlePriority</span>: <span class="hljs-title class_">Scheduler</span>_IdlePriority,
} = <span class="hljs-title class_">Scheduler</span>;

<span class="hljs-keyword">if</span> (enableSchedulerTracing) {
  <span class="hljs-comment">// Provide explicit error message when production+profiling bundle of e.g.</span>
  <span class="hljs-comment">// react-dom is used with production (non-profiling) bundle of</span>
  <span class="hljs-comment">// scheduler/tracing</span>
  <span class="hljs-title function_">invariant</span>(
    __interactionsRef != <span class="hljs-literal">null</span> &#x26;&#x26; __interactionsRef.<span class="hljs-property">current</span> != <span class="hljs-literal">null</span>,
    <span class="hljs-string">'It is not supported to run the profiling version of a renderer (for '</span> +
      <span class="hljs-string">'example, `react-dom/profiling`) without also replacing the '</span> +
      <span class="hljs-string">'`scheduler/tracing` module with `scheduler/tracing-profiling`. Your '</span> +
      <span class="hljs-string">'bundler might have a setting for aliasing both modules. Learn more at '</span> +
      <span class="hljs-string">'http://fb.me/react-profiling'</span>,
  );
}

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">ReactPriorityLevel</span> = <span class="hljs-number">99</span> | <span class="hljs-number">98</span> | <span class="hljs-number">97</span> | <span class="hljs-number">96</span> | <span class="hljs-number">95</span> | <span class="hljs-number">90</span>;
<span class="hljs-keyword">export</span> type <span class="hljs-title class_">SchedulerCallback</span> = <span class="hljs-function">(<span class="hljs-params">isSync: boolean</span>) =></span> <span class="hljs-title class_">SchedulerCallback</span> | <span class="hljs-literal">null</span>;

type <span class="hljs-title class_">SchedulerCallbackOptions</span> = {
  timeout?: number,
};

<span class="hljs-keyword">const</span> fakeCallbackNode = {};

<span class="hljs-comment">// Except for NoPriority, these correspond to Scheduler priorities. We use</span>
<span class="hljs-comment">// ascending numbers so we can compare them like numbers. They start at 90 to</span>
<span class="hljs-comment">// avoid clashing with Scheduler's priorities.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ImmediatePriority</span>: <span class="hljs-title class_">ReactPriorityLevel</span> = <span class="hljs-number">99</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserBlockingPriority</span>: <span class="hljs-title class_">ReactPriorityLevel</span> = <span class="hljs-number">98</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NormalPriority</span>: <span class="hljs-title class_">ReactPriorityLevel</span> = <span class="hljs-number">97</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LowPriority</span>: <span class="hljs-title class_">ReactPriorityLevel</span> = <span class="hljs-number">96</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IdlePriority</span>: <span class="hljs-title class_">ReactPriorityLevel</span> = <span class="hljs-number">95</span>;
<span class="hljs-comment">// NoPriority is the absence of priority. Also React-only.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoPriority</span>: <span class="hljs-title class_">ReactPriorityLevel</span> = <span class="hljs-number">90</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> shouldYield = <span class="hljs-title class_">Scheduler</span>_shouldYield;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> requestPaint =
  <span class="hljs-comment">// Fall back gracefully if we're running an older version of Scheduler.</span>
  <span class="hljs-title class_">Scheduler</span>_requestPaint !== <span class="hljs-literal">undefined</span> ? <span class="hljs-title class_">Scheduler</span>_requestPaint : <span class="hljs-function">() =></span> {};

<span class="hljs-keyword">let</span> <span class="hljs-attr">syncQueue</span>: <span class="hljs-title class_">Array</span>&#x3C;<span class="hljs-title class_">SchedulerCallback</span>> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">immediateQueueCallbackNode</span>: mixed | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">isFlushingSyncQueue</span>: boolean = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">initialTimeMs</span>: number = <span class="hljs-title class_">Scheduler</span>_now();

<span class="hljs-comment">// If the initial timestamp is reasonably small, use Scheduler's `now` directly.</span>
<span class="hljs-comment">// This will be the case for modern browsers that support `performance.now`. In</span>
<span class="hljs-comment">// older browsers, Scheduler falls back to `Date.now`, which returns a Unix</span>
<span class="hljs-comment">// timestamp. In that case, subtract the module initialization time to simulate</span>
<span class="hljs-comment">// the behavior of performance.now and keep our times small enough to fit</span>
<span class="hljs-comment">// within 32 bits.</span>
<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider lifting this into Scheduler.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> now =
  initialTimeMs &#x3C; <span class="hljs-number">10000</span> ? <span class="hljs-title class_">Scheduler</span>_now : <span class="hljs-function">() =></span> <span class="hljs-title class_">Scheduler</span>_now() - initialTimeMs;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentPriorityLevel</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">ReactPriorityLevel</span> {
  <span class="hljs-keyword">switch</span> (<span class="hljs-title class_">Scheduler</span>_getCurrentPriorityLevel()) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_ImmediatePriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">ImmediatePriority</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_UserBlockingPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserBlockingPriority</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_NormalPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">NormalPriority</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_LowPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">LowPriority</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_IdlePriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdlePriority</span>;
    <span class="hljs-attr">default</span>:
      <span class="hljs-title function_">invariant</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">'Unknown priority level.'</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">reactPriorityToSchedulerPriority</span>(<span class="hljs-params">reactPriorityLevel</span>) {
  <span class="hljs-keyword">switch</span> (reactPriorityLevel) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_ImmediatePriority;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_UserBlockingPriority;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_NormalPriority;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_LowPriority;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_IdlePriority;
    <span class="hljs-attr">default</span>:
      <span class="hljs-title function_">invariant</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">'Unknown priority level.'</span>);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> runWithPriority&#x3C;T>(
  <span class="hljs-attr">reactPriorityLevel</span>: <span class="hljs-title class_">ReactPriorityLevel</span>,
  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =></span> T,
): T {
  <span class="hljs-keyword">const</span> priorityLevel = <span class="hljs-title function_">reactPriorityToSchedulerPriority</span>(reactPriorityLevel);
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_runWithPriority(priorityLevel, fn);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-params">
  reactPriorityLevel: ReactPriorityLevel,
  callback: SchedulerCallback,
  options: SchedulerCallbackOptions | <span class="hljs-keyword">void</span> | <span class="hljs-literal">null</span>,
</span>) {
  <span class="hljs-keyword">const</span> priorityLevel = <span class="hljs-title function_">reactPriorityToSchedulerPriority</span>(reactPriorityLevel);
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_scheduleCallback(priorityLevel, callback, options);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleSyncCallback</span>(<span class="hljs-params">callback: SchedulerCallback</span>) {
  <span class="hljs-comment">// Push this callback into an internal queue. We'll flush these either in</span>
  <span class="hljs-comment">// the next tick, or earlier if something calls `flushSyncCallbackQueue`.</span>
  <span class="hljs-keyword">if</span> (syncQueue === <span class="hljs-literal">null</span>) {
    syncQueue = [callback];
    <span class="hljs-comment">// Flush the queue in the next tick, at the earliest.</span>
    immediateQueueCallbackNode = <span class="hljs-title class_">Scheduler</span>_scheduleCallback(
      <span class="hljs-title class_">Scheduler</span>_ImmediatePriority,
      flushSyncCallbackQueueImpl,
    );
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Push onto existing queue. Don't need to schedule a callback because</span>
    <span class="hljs-comment">// we already scheduled one when we created the queue.</span>
    syncQueue.<span class="hljs-title function_">push</span>(callback);
  }
  <span class="hljs-keyword">return</span> fakeCallbackNode;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cancelCallback</span>(<span class="hljs-params">callbackNode: mixed</span>) {
  <span class="hljs-keyword">if</span> (callbackNode !== fakeCallbackNode) {
    <span class="hljs-title class_">Scheduler</span>_cancelCallback(callbackNode);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSyncCallbackQueue</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (immediateQueueCallbackNode !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> node = immediateQueueCallbackNode;
    immediateQueueCallbackNode = <span class="hljs-literal">null</span>;
    <span class="hljs-title class_">Scheduler</span>_cancelCallback(node);
  }
  <span class="hljs-title function_">flushSyncCallbackQueueImpl</span>();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSyncCallbackQueueImpl</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (!isFlushingSyncQueue &#x26;&#x26; syncQueue !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// Prevent re-entrancy.</span>
    isFlushingSyncQueue = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> isSync = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">const</span> queue = syncQueue;
      <span class="hljs-title function_">runWithPriority</span>(<span class="hljs-title class_">ImmediatePriority</span>, <span class="hljs-function">() =></span> {
        <span class="hljs-keyword">for</span> (; i &#x3C; queue.<span class="hljs-property">length</span>; i++) {
          <span class="hljs-keyword">let</span> callback = queue[i];
          <span class="hljs-keyword">do</span> {
            callback = <span class="hljs-title function_">callback</span>(isSync);
          } <span class="hljs-keyword">while</span> (callback !== <span class="hljs-literal">null</span>);
        }
      });
      syncQueue = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// If something throws, leave the remaining callbacks on the queue.</span>
      <span class="hljs-keyword">if</span> (syncQueue !== <span class="hljs-literal">null</span>) {
        syncQueue = syncQueue.<span class="hljs-title function_">slice</span>(i + <span class="hljs-number">1</span>);
      }
      <span class="hljs-comment">// Resume flushing in the next tick</span>
      <span class="hljs-title class_">Scheduler</span>_scheduleCallback(
        <span class="hljs-title class_">Scheduler</span>_ImmediatePriority,
        flushSyncCallbackQueue,
      );
      <span class="hljs-keyword">throw</span> error;
    } <span class="hljs-keyword">finally</span> {
      isFlushingSyncQueue = <span class="hljs-literal">false</span>;
    }
  }
}

</code></pre>
<h2 id="reactworktagsjs">ReactWorkTags.js</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\shared\ReactWorkTags.js</span>
<span class="hljs-comment">/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * <span class="hljs-doctag">@flow</span>
 */</span>

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">WorkTag</span> =
  | <span class="hljs-number">0</span>
  | <span class="hljs-number">1</span>
  | <span class="hljs-number">2</span>
  | <span class="hljs-number">3</span>
  | <span class="hljs-number">4</span>
  | <span class="hljs-number">5</span>
  | <span class="hljs-number">6</span>
  | <span class="hljs-number">7</span>
  | <span class="hljs-number">8</span>
  | <span class="hljs-number">9</span>
  | <span class="hljs-number">10</span>
  | <span class="hljs-number">11</span>
  | <span class="hljs-number">12</span>
  | <span class="hljs-number">13</span>
  | <span class="hljs-number">14</span>
  | <span class="hljs-number">15</span>
  | <span class="hljs-number">16</span>
  | <span class="hljs-number">17</span>
  | <span class="hljs-number">18</span>
  | <span class="hljs-number">19</span>
  | <span class="hljs-number">20</span>
  | <span class="hljs-number">21</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">FunctionComponent</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ClassComponent</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IndeterminateComponent</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// Before we know whether it is function or class</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostRoot</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// Root of a host tree. Could be nested inside another node.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostPortal</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// A subtree. Could be an entry point to a different renderer.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostComponent</span> = <span class="hljs-number">5</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostText</span> = <span class="hljs-number">6</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Fragment</span> = <span class="hljs-number">7</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Mode</span> = <span class="hljs-number">8</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextConsumer</span> = <span class="hljs-number">9</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextProvider</span> = <span class="hljs-number">10</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ForwardRef</span> = <span class="hljs-number">11</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Profiler</span> = <span class="hljs-number">12</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SuspenseComponent</span> = <span class="hljs-number">13</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComponent</span> = <span class="hljs-number">14</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SimpleMemoComponent</span> = <span class="hljs-number">15</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LazyComponent</span> = <span class="hljs-number">16</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IncompleteClassComponent</span> = <span class="hljs-number">17</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">DehydratedFragment</span> = <span class="hljs-number">18</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SuspenseListComponent</span> = <span class="hljs-number">19</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">FundamentalComponent</span> = <span class="hljs-number">20</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ScopeComponent</span> = <span class="hljs-number">21</span>;

</code></pre>
<h2 id="reactsideeffecttagsjs">ReactSideEffectTags.js</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\shared\ReactSideEffectTags.js</span>
<span class="hljs-comment">/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * <span class="hljs-doctag">@flow</span>
 */</span>

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">SideEffectTag</span> = number;

<span class="hljs-comment">// Don't change these two values. They're used by React Dev Tools.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoEffect</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">PerformedWork</span> = <span class="hljs-comment">/*         */</span> <span class="hljs-number">0b0000000000001</span>;

<span class="hljs-comment">// You can change the rest (and add more).</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Placement</span> = <span class="hljs-comment">/*             */</span> <span class="hljs-number">0b0000000000010</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Update</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b0000000000100</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">PlacementAndUpdate</span> = <span class="hljs-comment">/*    */</span> <span class="hljs-number">0b0000000000110</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Deletion</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000000001000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContentReset</span> = <span class="hljs-comment">/*          */</span> <span class="hljs-number">0b0000000010000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000000100000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">DidCapture</span> = <span class="hljs-comment">/*            */</span> <span class="hljs-number">0b0000001000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Ref</span> = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b0000010000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Snapshot</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000100000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Passive</span> = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b0001000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Hydrating</span> = <span class="hljs-comment">/*             */</span> <span class="hljs-number">0b0010000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HydratingAndUpdate</span> = <span class="hljs-comment">/*    */</span> <span class="hljs-number">0b0010000000100</span>;

<span class="hljs-comment">// Passive &#x26; Update &#x26; Callback &#x26; Ref &#x26; Snapshot</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LifecycleEffectMask</span> = <span class="hljs-comment">/*   */</span> <span class="hljs-number">0b0001110100100</span>;

<span class="hljs-comment">// Union of all host effects</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostEffectMask</span> = <span class="hljs-comment">/*        */</span> <span class="hljs-number">0b0011111111111</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Incomplete</span> = <span class="hljs-comment">/*            */</span> <span class="hljs-number">0b0100000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ShouldCapture</span> = <span class="hljs-comment">/*         */</span> <span class="hljs-number">0b1000000000000</span>;

</code></pre>
<h2 id="reacttypeofmodejs">ReactTypeOfMode.js</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactTypeOfMode.js</span>
<span class="hljs-comment">/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * <span class="hljs-doctag">@flow</span>
 */</span>

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">TypeOfMode</span> = number;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoMode</span> = <span class="hljs-number">0b0000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">StrictMode</span> = <span class="hljs-number">0b0001</span>;
<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove BatchedMode and ConcurrentMode by reading from the root</span>
<span class="hljs-comment">// tag instead</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">BatchedMode</span> = <span class="hljs-number">0b0010</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ConcurrentMode</span> = <span class="hljs-number">0b0100</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ProfileMode</span> = <span class="hljs-number">0b1000</span>;

</code></pre>
<h2 id="reactfiberworkloopjs">ReactFiberWorkLoop.js</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">const</span> ceil = <span class="hljs-title class_">Math</span>.<span class="hljs-property">ceil</span>;

<span class="hljs-keyword">const</span> {
  <span class="hljs-title class_">ReactCurrentDispatcher</span>,
  <span class="hljs-title class_">ReactCurrentOwner</span>,
  <span class="hljs-title class_">IsSomeRendererActing</span>,
} = <span class="hljs-title class_">ReactSharedInternals</span>;

type <span class="hljs-title class_">ExecutionContext</span> = number;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">NoContext</span> = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b000000</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BatchedContext</span> = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b000001</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventContext</span> = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b000010</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">DiscreteEventContext</span> = <span class="hljs-comment">/*         */</span> <span class="hljs-number">0b000100</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">LegacyUnbatchedContext</span> = <span class="hljs-comment">/*       */</span> <span class="hljs-number">0b001000</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">RenderContext</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b010000</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CommitContext</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b100000</span>;

type <span class="hljs-title class_">RootExitStatus</span> = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">RootIncomplete</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">RootFatalErrored</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">RootErrored</span> = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">RootSuspended</span> = <span class="hljs-number">3</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">RootSuspendedWithDelay</span> = <span class="hljs-number">4</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">RootCompleted</span> = <span class="hljs-number">5</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">RootLocked</span> = <span class="hljs-number">6</span>;

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">Thenable</span> = {
  <span class="hljs-title function_">then</span>(<span class="hljs-attr">resolve</span>: <span class="hljs-function">() =></span> mixed, reject?: <span class="hljs-function">() =></span> mixed): <span class="hljs-title class_">Thenable</span> | <span class="hljs-keyword">void</span>,

  <span class="hljs-comment">// Special flag to opt out of tracing interactions across a Suspense boundary.</span>
  __reactDoNotTraceInteractions?: boolean,
};

<span class="hljs-comment">// Describes where we are in the React execution stack</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">executionContext</span>: <span class="hljs-title class_">ExecutionContext</span> = <span class="hljs-title class_">NoContext</span>;
<span class="hljs-comment">// The root we're working on</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgressRoot</span>: <span class="hljs-title class_">FiberRoot</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-comment">// The fiber we're working on</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgress</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-comment">// The expiration time we're rendering</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">renderExpirationTime</span>: <span class="hljs-title class_">ExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;
<span class="hljs-comment">// Whether to root completed, errored, suspended, etc.</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgressRootExitStatus</span>: <span class="hljs-title class_">RootExitStatus</span> = <span class="hljs-title class_">RootIncomplete</span>;
<span class="hljs-comment">// A fatal error, if one is thrown</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgressRootFatalError</span>: mixed = <span class="hljs-literal">null</span>;
<span class="hljs-comment">// Most recent event time among processed updates during this render.</span>
<span class="hljs-comment">// This is conceptually a time stamp but expressed in terms of an ExpirationTime</span>
<span class="hljs-comment">// because we deal mostly with expiration times in the hot path, so this avoids</span>
<span class="hljs-comment">// the conversion happening in the hot path.</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgressRootLatestProcessedExpirationTime</span>: <span class="hljs-title class_">ExpirationTime</span> = <span class="hljs-title class_">Sync</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgressRootLatestSuspenseTimeout</span>: <span class="hljs-title class_">ExpirationTime</span> = <span class="hljs-title class_">Sync</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgressRootCanSuspendUsingConfig</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">SuspenseConfig</span> = <span class="hljs-literal">null</span>;
<span class="hljs-comment">// The work left over by components that were visited during this render. Only</span>
<span class="hljs-comment">// includes unprocessed updates, not work in bailed out children.</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgressRootNextUnprocessedUpdateTime</span>: <span class="hljs-title class_">ExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;

<span class="hljs-comment">// If we're pinged while rendering we don't always restart immediately.</span>
<span class="hljs-comment">// This flag determines if it might be worthwhile to restart if an opportunity</span>
<span class="hljs-comment">// happens latere.</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workInProgressRootHasPendingPing</span>: boolean = <span class="hljs-literal">false</span>;
<span class="hljs-comment">// The most recent time we committed a fallback. This lets us ensure a train</span>
<span class="hljs-comment">// model where we don't commit new loading states in too quick succession.</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">globalMostRecentFallbackTime</span>: number = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">FALLBACK_THROTTLE_MS</span>: number = <span class="hljs-number">500</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">nextEffect</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> hasUncaughtError = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> firstUncaughtError = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">legacyErrorBoundariesThatAlreadyFailed</span>: <span class="hljs-title class_">Set</span>&#x3C;mixed> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">rootDoesHavePassiveEffects</span>: boolean = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">rootWithPendingPassiveEffects</span>: <span class="hljs-title class_">FiberRoot</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">pendingPassiveEffectsRenderPriority</span>: <span class="hljs-title class_">ReactPriorityLevel</span> = <span class="hljs-title class_">NoPriority</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">pendingPassiveEffectsExpirationTime</span>: <span class="hljs-title class_">ExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">rootsWithPendingDiscreteUpdates</span>: <span class="hljs-title class_">Map</span>&#x3C;
  <span class="hljs-title class_">FiberRoot</span>,
  <span class="hljs-title class_">ExpirationTime</span>,
> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// Use these to prevent an infinite loop of nested updates</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NESTED_UPDATE_LIMIT</span> = <span class="hljs-number">50</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">nestedUpdateCount</span>: number = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">rootWithNestedUpdates</span>: <span class="hljs-title class_">FiberRoot</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NESTED_PASSIVE_UPDATE_LIMIT</span> = <span class="hljs-number">50</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">nestedPassiveUpdateCount</span>: number = <span class="hljs-number">0</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">interruptedBy</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// Marks the need to reschedule pending interactions at these expiration times</span>
<span class="hljs-comment">// during the commit phase. This enables them to be traced across components</span>
<span class="hljs-comment">// that spawn new work during render. E.g. hidden boundaries, suspended SSR</span>
<span class="hljs-comment">// hydration or SuspenseList.</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">spawnedWorkDuringRender</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Array</span>&#x3C;<span class="hljs-title class_">ExpirationTime</span>> = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// Expiration times are computed by adding to the current time (the start</span>
<span class="hljs-comment">// time). However, if two updates are scheduled within the same event, we</span>
<span class="hljs-comment">// should treat their start times as simultaneous, even if the actual clock</span>
<span class="hljs-comment">// time has advanced between the first and second call.</span>

<span class="hljs-comment">// In other words, because expiration times determine how updates are batched,</span>
<span class="hljs-comment">// we want all updates of like priority that occur within the same event to</span>
<span class="hljs-comment">// receive the same expiration time. Otherwise we get tearing.</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">currentEventTime</span>: <span class="hljs-title class_">ExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;
</code></pre>
<h2 id="reactsharedinternalsjs">ReactSharedInternals.js</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//packages\shared\ReactSharedInternals.js</span>
<span class="hljs-comment">/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactSharedInternals</span> =
  <span class="hljs-title class_">React</span>.<span class="hljs-property">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span>;

<span class="hljs-comment">// Prevent newer renderers from RTE when used with older react package versions.</span>
<span class="hljs-comment">// Current owner and dispatcher used to share the same ref,</span>
<span class="hljs-comment">// but PR #14548 split them out to better support the react-debug-tools package.</span>
<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'ReactCurrentDispatcher'</span>)) {
  <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentDispatcher</span> = {
    <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>,
  };
}
<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'ReactCurrentBatchConfig'</span>)) {
  <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentBatchConfig</span> = {
    <span class="hljs-attr">suspense</span>: <span class="hljs-literal">null</span>,
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ReactSharedInternals</span>;

</code></pre>
<h1 id="reactdomrender调用过程">ReactDOM.render调用过程</h1>
<h2 id="reactdomrender">ReactDOM.render</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-dom\src\client\ReactDOM.js</span>
<span class="hljs-title function_">render</span>(<span class="hljs-params">
    element: React$Element&#x3C;any>,
    container: DOMContainer,
    callback: ?<span class="hljs-built_in">Function</span>,
  </span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>(
      <span class="hljs-literal">null</span>,
      element,
      container,
      <span class="hljs-literal">false</span>,
      callback,
    );
  }
</code></pre>
<h2 id="legacyrendersubtreeintocontainer">legacyRenderSubtreeIntoContainer</h2>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-dom\src\client\ReactDOM.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>(<span class="hljs-params">
  parentComponent: ?React$Component&#x3C;any, any>,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?<span class="hljs-built_in">Function</span>,
</span>) {
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Without `any` type, Flow says "Property cannot be accessed on any</span>
  <span class="hljs-comment">// member of intersection type." Whyyyyyy.</span>
  <span class="hljs-keyword">let</span> <span class="hljs-attr">root</span>: _ReactSyncRoot = (container.<span class="hljs-property">_reactRootContainer</span>: any);
  <span class="hljs-keyword">let</span> fiberRoot;
  <span class="hljs-comment">// 没有root则创建，有了root之后执行update</span>
  <span class="hljs-keyword">if</span> (!root) {
    <span class="hljs-comment">// Initial mount</span>
    root = container.<span class="hljs-property">_reactRootContainer</span> = <span class="hljs-title function_">legacyCreateRootFromDOMContainer</span>(
      container,
      forceHydrate,
    );
    fiberRoot = root.<span class="hljs-property">_internalRoot</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">const</span> originalCallback = callback;
      callback = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getPublicRootInstance</span>(fiberRoot);
        originalCallback.<span class="hljs-title function_">call</span>(instance);
      };
    }
    <span class="hljs-comment">// Initial mount should not be batched.</span>
    <span class="hljs-title function_">unbatchedUpdates</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);
    });
  } <span class="hljs-keyword">else</span> {
    fiberRoot = root.<span class="hljs-property">_internalRoot</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">const</span> originalCallback = callback;
      callback = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getPublicRootInstance</span>(fiberRoot);
        originalCallback.<span class="hljs-title function_">call</span>(instance);
      };
    }
    <span class="hljs-comment">// Update</span>
    <span class="hljs-title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPublicRootInstance</span>(fiberRoot);
}
</code></pre>
<h3 id="root创建过程">root创建过程</h3>
<h4 id="legacycreaterootfromdomcontainer">legacyCreateRootFromDOMContainer</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-dom\src\client\ReactDOM.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyCreateRootFromDOMContainer</span>(<span class="hljs-params">
  container: DOMContainer,
  forceHydrate: boolean,
</span>): _ReactSyncRoot {
  <span class="hljs-comment">// hydrate 描述的是 ReactDOM 复用 ReactDOMServer 服务端渲染的内容时尽可能保留结构，并补充事件绑定等 Client 特有内容的过程。</span>
  <span class="hljs-keyword">const</span> shouldHydrate =
    forceHydrate || <span class="hljs-title function_">shouldHydrateDueToLegacyHeuristic</span>(container);
  <span class="hljs-comment">// First clear any existing content.</span>
  <span class="hljs-keyword">if</span> (!shouldHydrate) {
    <span class="hljs-keyword">let</span> warned = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> rootSibling;
    <span class="hljs-keyword">while</span> ((rootSibling = container.<span class="hljs-property">lastChild</span>)) {
      <span class="hljs-keyword">if</span> (__DEV__) {
        <span class="hljs-keyword">if</span> (
          !warned &#x26;&#x26;
          rootSibling.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span> &#x26;&#x26;
          (<span class="hljs-attr">rootSibling</span>: any).<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-variable constant_">ROOT_ATTRIBUTE_NAME</span>)
        ) {
          warned = <span class="hljs-literal">true</span>;
          <span class="hljs-title function_">warningWithoutStack</span>(
            <span class="hljs-literal">false</span>,
            <span class="hljs-string">'render(): Target node has markup rendered by React, but there '</span> +
              <span class="hljs-string">'are unrelated nodes as well. This is most commonly caused by '</span> +
              <span class="hljs-string">'white-space inserted around server-rendered markup.'</span>,
          );
        }
      }
      container.<span class="hljs-title function_">removeChild</span>(rootSibling);
    }
  }

  <span class="hljs-comment">// Legacy roots are not batched.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactSyncRoot</span>(
    container,
    <span class="hljs-title class_">LegacyRoot</span>,
    shouldHydrate
      ? {
          <span class="hljs-attr">hydrate</span>: <span class="hljs-literal">true</span>,
        }
      : <span class="hljs-literal">undefined</span>,
  );
}
</code></pre>
<h4 id="new-reactsyncroot">new ReactSyncRoot</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-dom\src\client\ReactDOM.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ReactSyncRoot</span>(<span class="hljs-params">
  container: DOMContainer,
  tag: RootTag,
  options: <span class="hljs-keyword">void</span> | RootOptions,
</span>) {
  <span class="hljs-comment">// 挂载fiberRoot</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span> = <span class="hljs-title function_">createRootImpl</span>(container, tag, options);
}

<span class="hljs-title class_">ReactRoot</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-title class_">ReactSyncRoot</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">
  children: ReactNodeList,
  callback: ?() => mixed,
</span>): <span class="hljs-title class_">Work</span> {
  <span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span>;
  <span class="hljs-keyword">const</span> work = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactWork</span>();
  callback = callback === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : callback;
  <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
    work.<span class="hljs-title function_">then</span>(callback);
  }
  <span class="hljs-title function_">updateContainer</span>(children, root, <span class="hljs-literal">null</span>, work.<span class="hljs-property">_onCommit</span>);
  <span class="hljs-keyword">return</span> work;
};

<span class="hljs-title class_">ReactRoot</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">unmount</span> = <span class="hljs-title class_">ReactSyncRoot</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">unmount</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">
  callback: ?() => mixed,
</span>): <span class="hljs-title class_">Work</span> {
  <span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span>;
  <span class="hljs-keyword">const</span> work = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactWork</span>();
  callback = callback === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : callback;
  <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
    work.<span class="hljs-title function_">then</span>(callback);
  }
  <span class="hljs-title function_">updateContainer</span>(<span class="hljs-literal">null</span>, root, <span class="hljs-literal">null</span>, work.<span class="hljs-property">_onCommit</span>);
  <span class="hljs-keyword">return</span> work;
};
</code></pre>
<h4 id="createrootimpl">createRootImpl</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-dom\src\client\ReactDOM.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createRootImpl</span>(<span class="hljs-params">
  container: DOMContainer,
  tag: RootTag,
  options: <span class="hljs-keyword">void</span> | RootOptions,
</span>) {
  <span class="hljs-comment">// Tag is either LegacyRoot or Concurrent Root</span>
  <span class="hljs-keyword">const</span> hydrate = options != <span class="hljs-literal">null</span> &#x26;&#x26; options.<span class="hljs-property">hydrate</span> === <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">const</span> hydrationCallbacks =
    (options != <span class="hljs-literal">null</span> &#x26;&#x26; options.<span class="hljs-property">hydrationOptions</span>) || <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createContainer</span>(container, tag, hydrate, hydrationCallbacks);
  <span class="hljs-title function_">markContainerAsRoot</span>(root.<span class="hljs-property">current</span>, container);
  <span class="hljs-keyword">if</span> (hydrate &#x26;&#x26; tag !== <span class="hljs-title class_">LegacyRoot</span>) {
    <span class="hljs-keyword">const</span> doc =
      container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">DOCUMENT_NODE</span>
        ? container
        : container.<span class="hljs-property">ownerDocument</span>;
    <span class="hljs-title function_">eagerlyTrapReplayableEvents</span>(doc);
  }
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 id="createcontainer">createContainer</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberReconciler.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createContainer</span>(<span class="hljs-params">
  containerInfo: Container,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: <span class="hljs-literal">null</span> | SuspenseHydrationCallbacks,
</span>): <span class="hljs-title class_">OpaqueRoot</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberRoot</span>(containerInfo, tag, hydrate, hydrationCallbacks);
}
</code></pre>
<h6 id="createfiberroot">createFiberRoot</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberRoot.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberRoot</span>(<span class="hljs-params">
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: <span class="hljs-literal">null</span> | SuspenseHydrationCallbacks,
</span>): <span class="hljs-title class_">FiberRoot</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">root</span>: <span class="hljs-title class_">FiberRoot</span> = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FiberRootNode</span>(containerInfo, tag, hydrate): any);
  <span class="hljs-keyword">if</span> (enableSuspenseCallback) {
    root.<span class="hljs-property">hydrationCallbacks</span> = hydrationCallbacks;
  }

  <span class="hljs-comment">// Cyclic construction. This cheats the type system right now because</span>
  <span class="hljs-comment">// stateNode is any.</span>
  <span class="hljs-keyword">const</span> uninitializedFiber = <span class="hljs-title function_">createHostRootFiber</span>(tag);
  root.<span class="hljs-property">current</span> = uninitializedFiber;
  uninitializedFiber.<span class="hljs-property">stateNode</span> = root;

  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h6 id="new-fiberrootnode">new FiberRootNode</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberRoot.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberRootNode</span>(<span class="hljs-params">containerInfo, tag, hydrate</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">containerInfo</span> = containerInfo;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingChildren</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pingCache</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">finishedExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">finishedWork</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timeoutHandle</span> = noTimeout;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingContext</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">hydrate</span> = hydrate;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstBatch</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// NoPriority 详见React类型/常量定义-SchedulerWithReactIntegration.js</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoPriority</span>;
  <span class="hljs-comment">// NoWork 详见React类型/常量定义-ReactFiberExpirationTime.js</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstPendingTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstSuspendedTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastSuspendedTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextKnownPendingLevel</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastPingedTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastExpiredTime</span> = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interactionThreadID</span> = <span class="hljs-title function_">unstable_getThreadID</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedInteractions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingInteractionMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  }
  <span class="hljs-keyword">if</span> (enableSuspenseCallback) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hydrationCallbacks</span> = <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h6 id="createhostrootfiber">createHostRootFiber</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiber.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createHostRootFiber</span>(<span class="hljs-params">tag: RootTag</span>): <span class="hljs-title class_">Fiber</span> {
  <span class="hljs-keyword">let</span> mode;
    
  <span class="hljs-comment">// ConcurrentMode、BatchedMode 详见React类型/常量定义-ReactTypeOfMode.js</span>
  <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">ConcurrentRoot</span>) {
    mode = <span class="hljs-title class_">ConcurrentMode</span> | <span class="hljs-title class_">BatchedMode</span> | <span class="hljs-title class_">StrictMode</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">BatchedRoot</span>) {
    mode = <span class="hljs-title class_">BatchedMode</span> | <span class="hljs-title class_">StrictMode</span>;
  } <span class="hljs-keyword">else</span> {
    mode = <span class="hljs-title class_">NoMode</span>;
  }

  <span class="hljs-keyword">if</span> (enableProfilerTimer &#x26;&#x26; isDevToolsPresent) {
    <span class="hljs-comment">// Always collect profile timings when DevTools are present.</span>
    <span class="hljs-comment">// This enables DevTools to start capturing timing at any point–</span>
    <span class="hljs-comment">// Without some nodes in the tree having empty base times.</span>
    mode |= <span class="hljs-title class_">ProfileMode</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">HostRoot</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, mode);
}
</code></pre>
<h6 id="createfiber">createFiber</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiber.js</span>
<span class="hljs-keyword">const</span> createFiber = <span class="hljs-keyword">function</span>(<span class="hljs-params">
  tag: WorkTag,
  pendingProps: mixed,
  key: <span class="hljs-literal">null</span> | string,
  mode: TypeOfMode,
</span>): <span class="hljs-title class_">Fiber</span> {
  <span class="hljs-comment">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FiberNode</span>(tag, pendingProps, key, mode);
};
</code></pre>
<h6 id="new-fibernode">new FiberNode</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiber.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params">
  tag: WorkTag,
  pendingProps: mixed,
  key: <span class="hljs-literal">null</span> | string,
  mode: TypeOfMode,
</span>) {
  <span class="hljs-comment">// Instance</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementType</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// Fiber</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode;

  <span class="hljs-comment">// Effects</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">NoEffect</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">expirationTime</span> = <span class="hljs-title class_">NoWork</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (enableProfilerTimer) {
    <span class="hljs-comment">// Note: The following is done to avoid a v8 performance cliff.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Initializing the fields below to smis and later updating them with</span>
    <span class="hljs-comment">// double values will cause Fibers to end up having separate shapes.</span>
    <span class="hljs-comment">// This behavior/bug has something to do with Object.preventExtension().</span>
    <span class="hljs-comment">// Fortunately this only impacts DEV builds.</span>
    <span class="hljs-comment">// Unfortunately it makes React unusably slow for some applications.</span>
    <span class="hljs-comment">// To work around this, initialize the fields below with doubles.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Learn more about this here:</span>
    <span class="hljs-comment">// https://github.com/facebook/react/issues/14365</span>
    <span class="hljs-comment">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;

    <span class="hljs-comment">// It's okay to replace the initial doubles with smis after initialization.</span>
    <span class="hljs-comment">// This won't trigger the performance cliff mentioned above,</span>
    <span class="hljs-comment">// and it simplifies other profiler code (including DevTools).</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// This is normally DEV-only except www when it adds listeners.</span>
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> remove the User Timing integration in favor of Root Events.</span>
  <span class="hljs-keyword">if</span> (enableUserTimingAPI) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugID</span> = debugCounter++;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugIsCurrentlyTiming</span> = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">if</span> (__DEV__) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugSource</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugOwner</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugNeedsRemount</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugHookTypes</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (!hasBadMapPolyfill &#x26;&#x26; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">preventExtensions</span> === <span class="hljs-string">'function'</span>) {
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(<span class="hljs-variable language_">this</span>);
    }
  }
}
</code></pre>
<h5 id="markcontainerasroot">markContainerAsRoot</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-dom\src\client\ReactDOMComponentTree.js</span>
<span class="hljs-keyword">const</span> randomKey = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()
  .<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>)
  .<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> internalInstanceKey = <span class="hljs-string">'__reactInternalInstance$'</span> + randomKey;
<span class="hljs-keyword">const</span> internalEventHandlersKey = <span class="hljs-string">'__reactEventHandlers$'</span> + randomKey;
<span class="hljs-keyword">const</span> internalContainerInstanceKey = <span class="hljs-string">'__reactContainere$'</span> + randomKey;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">precacheFiberNode</span>(<span class="hljs-params">hostInst, node</span>) {
  node[internalInstanceKey] = hostInst;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">markContainerAsRoot</span>(<span class="hljs-params">hostRoot, node</span>) {
  node[internalContainerInstanceKey] = hostRoot;
}
</code></pre>
<h3 id="callback调用过程">callback调用过程</h3>
<h4 id="getpublicrootinstance">getPublicRootInstance</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberReconciler.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPublicRootInstance</span>(<span class="hljs-params">
  container: OpaqueRoot,
</span>): <span class="hljs-title class_">React</span>$Component&#x3C;any, any> | <span class="hljs-title class_">PublicInstance</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">const</span> containerFiber = container.<span class="hljs-property">current</span>;
  <span class="hljs-keyword">if</span> (!containerFiber.<span class="hljs-property">child</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">switch</span> (containerFiber.<span class="hljs-property">child</span>.<span class="hljs-property">tag</span>) {
    <span class="hljs-comment">// HostComponent 详见React类型/常量定义-ReactWorkTags.js</span>
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPublicInstance</span>(containerFiber.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>);
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> containerFiber.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>;
  }
}
</code></pre>
<h3 id="updatecontainer调用过程">updateContainer调用过程</h3>
<h4 id="unbatchedupdates">unbatchedUpdates</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> unbatchedUpdates&#x3C;A, R>(<span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">a: A</span>) =></span> R, <span class="hljs-attr">a</span>: A): R {
  <span class="hljs-comment">// executionContext、BatchedContext 详见React类型/常量定义-ReactFiberWorkLoop.js</span>
  <span class="hljs-keyword">const</span> prevExecutionContext = executionContext;
  executionContext &#x26;= ~<span class="hljs-title class_">BatchedContext</span>;
  executionContext |= <span class="hljs-title class_">LegacyUnbatchedContext</span>;
  <span class="hljs-comment">// executionContext now is 8</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a);
  } <span class="hljs-keyword">finally</span> {
    executionContext = prevExecutionContext;
    <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {
      <span class="hljs-comment">// Flush the immediate callbacks that were scheduled during this batch</span>
      <span class="hljs-title function_">flushSyncCallbackQueue</span>();
    }
  }
}
</code></pre>
<h4 id="updatecontainer">updateContainer</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberReconciler.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainer</span>(<span class="hljs-params">
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&#x3C;any, any>,
  callback: ?<span class="hljs-built_in">Function</span>,
</span>): <span class="hljs-title class_">ExpirationTime</span> {
  <span class="hljs-keyword">const</span> current = container.<span class="hljs-property">current</span>;
  <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">requestCurrentTime</span>();
  <span class="hljs-keyword">if</span> (__DEV__) {
    <span class="hljs-comment">// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'undefined'</span> !== <span class="hljs-keyword">typeof</span> jest) {
      <span class="hljs-title function_">warnIfUnmockedScheduler</span>(current);
      <span class="hljs-title function_">warnIfNotScopedWithMatchingAct</span>(current);
    }
  }
  <span class="hljs-keyword">const</span> suspenseConfig = <span class="hljs-title function_">requestCurrentSuspenseConfig</span>();
  <span class="hljs-keyword">const</span> expirationTime = <span class="hljs-title function_">computeExpirationForFiber</span>(
    currentTime,
    current,
    suspenseConfig,
  );
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateContainerAtExpirationTime</span>(
    element,
    container,
    parentComponent,
    expirationTime,
    suspenseConfig,
    callback,
  );
}
</code></pre>
<h5 id="requestcurrenttime">requestCurrentTime</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">requestCurrentTime</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> ((executionContext &#x26; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) !== <span class="hljs-title class_">NoContext</span>) {
    <span class="hljs-comment">// We're inside React, so it's fine to read the actual time.</span>
    <span class="hljs-comment">// now()方法的定义：如果是浏览器支持则定义为()=>performance.now()，否则为Date.now()-react库加载执行时的Date.now()</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">msToExpirationTime</span>(<span class="hljs-title function_">now</span>());
  }
  <span class="hljs-comment">// We're not inside React, so we may be in the middle of a browser event.</span>
  <span class="hljs-keyword">if</span> (currentEventTime !== <span class="hljs-title class_">NoWork</span>) {
    <span class="hljs-comment">// Use the same start time for all updates until we enter React again.</span>
    <span class="hljs-keyword">return</span> currentEventTime;
  }
  <span class="hljs-comment">// This is the first update since React yielded. Compute a new start time.</span>
  <span class="hljs-comment">// 1073741823-1-1-now()</span>
  currentEventTime = <span class="hljs-title function_">msToExpirationTime</span>(<span class="hljs-title function_">now</span>());
  <span class="hljs-keyword">return</span> currentEventTime;
}
</code></pre>
<h5 id="mstoexpirationtime">msToExpirationTime</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberExpirationTime.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">msToExpirationTime</span>(<span class="hljs-params">ms: number</span>): <span class="hljs-title class_">ExpirationTime</span> {
  <span class="hljs-comment">// Always add an offset so that we don't clash with the magic number for NoWork.</span>
  <span class="hljs-comment">// MAGIC_NUMBER_OFFSET、UNIT_SIZE 详见React类型/常量定义-ReactFiberExpirationTime.js</span>
  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">MAGIC_NUMBER_OFFSET</span> - ((ms / <span class="hljs-variable constant_">UNIT_SIZE</span>) | <span class="hljs-number">0</span>);
}
</code></pre>
<h5 id="requestcurrentsuspenseconfig">requestCurrentSuspenseConfig</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberSuspenseConfig.js</span>
<span class="hljs-comment">/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * <span class="hljs-doctag">@flow</span>
 */</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactSharedInternals</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'shared/ReactSharedInternals'</span>;

<span class="hljs-keyword">const</span> {<span class="hljs-title class_">ReactCurrentBatchConfig</span>} = <span class="hljs-title class_">ReactSharedInternals</span>;

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">SuspenseConfig</span> = {|
  <span class="hljs-attr">timeoutMs</span>: number,
  busyDelayMs?: number,
  busyMinDurationMs?: number,
|};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">requestCurrentSuspenseConfig</span>(<span class="hljs-params"></span>): <span class="hljs-literal">null</span> | <span class="hljs-title class_">SuspenseConfig</span> {
  <span class="hljs-comment">// ReactCurrentBatchConfig 详见React类型/常量定义-ReactSharedInternals.js</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactCurrentBatchConfig</span>.<span class="hljs-property">suspense</span>;
}

</code></pre>
<h5 id="computeexpirationforfiber">computeExpirationForFiber</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computeExpirationForFiber</span>(<span class="hljs-params">
  currentTime: ExpirationTime,
  fiber: Fiber,
  suspenseConfig: <span class="hljs-literal">null</span> | SuspenseConfig,
</span>): <span class="hljs-title class_">ExpirationTime</span> {
  <span class="hljs-keyword">const</span> mode = fiber.<span class="hljs-property">mode</span>;
  <span class="hljs-keyword">if</span> ((mode &#x26; <span class="hljs-title class_">BatchedMode</span>) === <span class="hljs-title class_">NoMode</span>) {
    <span class="hljs-comment">// Sync 详见React类型/常量定义-ReactFiberExpirationTime.js</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Sync</span>;
  }

  <span class="hljs-keyword">const</span> priorityLevel = <span class="hljs-title function_">getCurrentPriorityLevel</span>();
  <span class="hljs-keyword">if</span> ((mode &#x26; <span class="hljs-title class_">ConcurrentMode</span>) === <span class="hljs-title class_">NoMode</span>) {
    <span class="hljs-keyword">return</span> priorityLevel === <span class="hljs-title class_">ImmediatePriority</span> ? <span class="hljs-title class_">Sync</span> : <span class="hljs-title class_">Batched</span>;
  }

  <span class="hljs-keyword">if</span> ((executionContext &#x26; <span class="hljs-title class_">RenderContext</span>) !== <span class="hljs-title class_">NoContext</span>) {
    <span class="hljs-comment">// Use whatever time we're already rendering</span>
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Should there be a way to opt out, like with `runWithPriority`?</span>
    <span class="hljs-keyword">return</span> renderExpirationTime;
  }

  <span class="hljs-keyword">let</span> expirationTime;
  <span class="hljs-keyword">if</span> (suspenseConfig !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// Compute an expiration time based on the Suspense timeout.</span>
    expirationTime = <span class="hljs-title function_">computeSuspenseExpiration</span>(
      currentTime,
      suspenseConfig.<span class="hljs-property">timeoutMs</span> | <span class="hljs-number">0</span> || <span class="hljs-variable constant_">LOW_PRIORITY_EXPIRATION</span>,
    );
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Compute an expiration time based on the Scheduler priority.</span>
    <span class="hljs-keyword">switch</span> (priorityLevel) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:
        expirationTime = <span class="hljs-title class_">Sync</span>;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Rename this to computeUserBlockingExpiration</span>
        expirationTime = <span class="hljs-title function_">computeInteractiveExpiration</span>(currentTime);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>: <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Handle LowPriority</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Rename this to... something better.</span>
        expirationTime = <span class="hljs-title function_">computeAsyncExpiration</span>(currentTime);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:
        expirationTime = <span class="hljs-title class_">Idle</span>;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-attr">default</span>:
        <span class="hljs-title function_">invariant</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">'Expected a valid priority level'</span>);
    }
  }

  <span class="hljs-comment">// If we're in the middle of rendering a tree, do not update at the same</span>
  <span class="hljs-comment">// expiration time that is already rendering.</span>
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> We shouldn't have to do this if the update is on a different root.</span>
  <span class="hljs-comment">// Refactor computeExpirationForFiber + scheduleUpdate so we have access to</span>
  <span class="hljs-comment">// the root when we check for this condition.</span>
  <span class="hljs-keyword">if</span> (workInProgressRoot !== <span class="hljs-literal">null</span> &#x26;&#x26; expirationTime === renderExpirationTime) {
    <span class="hljs-comment">// This is a trick to move this update into a separate batch</span>
    expirationTime -= <span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">return</span> expirationTime;
}
</code></pre>
<h4 id="updatecontaineratexpirationtime">updateContainerAtExpirationTime</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberReconciler.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainerAtExpirationTime</span>(<span class="hljs-params">
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&#x3C;any, any>,
  expirationTime: ExpirationTime,
  suspenseConfig: <span class="hljs-literal">null</span> | SuspenseConfig,
  callback: ?<span class="hljs-built_in">Function</span>,
</span>) {
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If this is a nested container, this won't be the root.</span>
  <span class="hljs-keyword">const</span> current = container.<span class="hljs-property">current</span>;

  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">getContextForSubtree</span>(parentComponent);
  <span class="hljs-keyword">if</span> (container.<span class="hljs-property">context</span> === <span class="hljs-literal">null</span>) {
    container.<span class="hljs-property">context</span> = context;
  } <span class="hljs-keyword">else</span> {
    container.<span class="hljs-property">pendingContext</span> = context;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">scheduleRootUpdate</span>(
    current,
    element,
    expirationTime,
    suspenseConfig,
    callback,
  );
}
</code></pre>
<h5 id="getcontextforsubtree">getContextForSubtree</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberReconciler.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getContextForSubtree</span>(<span class="hljs-params">
  parentComponent: ?React$Component&#x3C;any, any>,
</span>): <span class="hljs-title class_">Object</span> {
  <span class="hljs-keyword">if</span> (!parentComponent) {
    <span class="hljs-keyword">return</span> emptyContextObject;
  }
  <span class="hljs-comment">// 此处取的是parentComponent._reactInternalFiber</span>
  <span class="hljs-keyword">const</span> fiber = <span class="hljs-title function_">getInstance</span>(parentComponent);
  <span class="hljs-keyword">const</span> parentContext = <span class="hljs-title function_">findCurrentUnmaskedContext</span>(fiber);

  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = fiber.<span class="hljs-property">type</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isLegacyContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">processChildContext</span>(fiber, <span class="hljs-title class_">Component</span>, parentContext);
    }
  }

  <span class="hljs-keyword">return</span> parentContext;
}
</code></pre>
<h5 id="findcurrentunmaskedcontext">findCurrentUnmaskedContext</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberContext.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findCurrentUnmaskedContext</span>(<span class="hljs-params">fiber: Fiber</span>): <span class="hljs-title class_">Object</span> {
  <span class="hljs-keyword">if</span> (disableLegacyContext) {
    <span class="hljs-keyword">return</span> emptyContextObject;
  } <span class="hljs-keyword">else</span> {

    <span class="hljs-keyword">let</span> node = fiber;
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
          <span class="hljs-keyword">return</span> node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">context</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: {
          <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = node.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
            <span class="hljs-keyword">return</span> node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">__reactInternalMemoizedMergedChildContext</span>;
          }
          <span class="hljs-keyword">break</span>;
        }
      }
      node = node.<span class="hljs-property">return</span>;
    } <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>);
  }
}
</code></pre>
<h4 id="schedulerootupdate">scheduleRootUpdate</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberReconciler.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleRootUpdate</span>(<span class="hljs-params">
  current: Fiber,
  element: ReactNodeList,
  expirationTime: ExpirationTime,
  suspenseConfig: <span class="hljs-literal">null</span> | SuspenseConfig,
  callback: ?<span class="hljs-built_in">Function</span>,
</span>) {
  <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(expirationTime, suspenseConfig);
  <span class="hljs-comment">// Caution: React DevTools currently depends on this property</span>
  <span class="hljs-comment">// being called "element".</span>
  update.<span class="hljs-property">payload</span> = {element};

  callback = callback === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : callback;
  <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
    <span class="hljs-title function_">warningWithoutStack</span>(
      <span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>,
      <span class="hljs-string">'render(...): Expected the last optional `callback` argument to be a '</span> +
        <span class="hljs-string">'function. Instead received: %s.'</span>,
      callback,
    );
    update.<span class="hljs-property">callback</span> = callback;
  }

  <span class="hljs-title function_">enqueueUpdate</span>(current, update);
  <span class="hljs-title function_">scheduleWork</span>(current, expirationTime);

  <span class="hljs-keyword">return</span> expirationTime;
}
</code></pre>
<h5 id="createupdate">createUpdate</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createUpdate</span>(<span class="hljs-params">
  expirationTime: ExpirationTime,
  suspenseConfig: <span class="hljs-literal">null</span> | SuspenseConfig,
</span>): <span class="hljs-title class_">Update</span>&#x3C;*> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">update</span>: <span class="hljs-title class_">Update</span>&#x3C;*> = {
    expirationTime,
    suspenseConfig,

    <span class="hljs-attr">tag</span>: <span class="hljs-title class_">UpdateState</span>,
    <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,

    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">nextEffect</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-keyword">if</span> (__DEV__) {
    update.<span class="hljs-property">priority</span> = <span class="hljs-title function_">getCurrentPriorityLevel</span>();
  }
  <span class="hljs-keyword">return</span> update;
}
</code></pre>
<h5 id="enqueueupdate">enqueueUpdate</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> enqueueUpdate&#x3C;<span class="hljs-title class_">State</span>>(<span class="hljs-attr">fiber</span>: <span class="hljs-title class_">Fiber</span>, <span class="hljs-attr">update</span>: <span class="hljs-title class_">Update</span>&#x3C;<span class="hljs-title class_">State</span>>) {
  <span class="hljs-comment">// Update queues are created lazily.</span>
  <span class="hljs-keyword">const</span> alternate = fiber.<span class="hljs-property">alternate</span>;
  <span class="hljs-keyword">let</span> queue1;
  <span class="hljs-keyword">let</span> queue2;
  <span class="hljs-keyword">if</span> (alternate === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// There's only one fiber.</span>
    queue1 = fiber.<span class="hljs-property">updateQueue</span>;
    queue2 = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (queue1 === <span class="hljs-literal">null</span>) {
      queue1 = fiber.<span class="hljs-property">updateQueue</span> = <span class="hljs-title function_">createUpdateQueue</span>(fiber.<span class="hljs-property">memoizedState</span>);
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// There are two owners.</span>
    queue1 = fiber.<span class="hljs-property">updateQueue</span>;
    queue2 = alternate.<span class="hljs-property">updateQueue</span>;
    <span class="hljs-keyword">if</span> (queue1 === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (queue2 === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// Neither fiber has an update queue. Create new ones.</span>
        queue1 = fiber.<span class="hljs-property">updateQueue</span> = <span class="hljs-title function_">createUpdateQueue</span>(fiber.<span class="hljs-property">memoizedState</span>);
        queue2 = alternate.<span class="hljs-property">updateQueue</span> = <span class="hljs-title function_">createUpdateQueue</span>(
          alternate.<span class="hljs-property">memoizedState</span>,
        );
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Only one fiber has an update queue. Clone to create a new one.</span>
        queue1 = fiber.<span class="hljs-property">updateQueue</span> = <span class="hljs-title function_">cloneUpdateQueue</span>(queue2);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (queue2 === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// Only one fiber has an update queue. Clone to create a new one.</span>
        queue2 = alternate.<span class="hljs-property">updateQueue</span> = <span class="hljs-title function_">cloneUpdateQueue</span>(queue1);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Both owners have an update queue.</span>
      }
    }
  }
  <span class="hljs-keyword">if</span> (queue2 === <span class="hljs-literal">null</span> || queue1 === queue2) {
    <span class="hljs-comment">// There's only a single queue.</span>
    <span class="hljs-title function_">appendUpdateToQueue</span>(queue1, update);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// There are two queues. We need to append the update to both queues,</span>
    <span class="hljs-comment">// while accounting for the persistent structure of the list — we don't</span>
    <span class="hljs-comment">// want the same update to be added multiple times.</span>
    <span class="hljs-keyword">if</span> (queue1.<span class="hljs-property">lastUpdate</span> === <span class="hljs-literal">null</span> || queue2.<span class="hljs-property">lastUpdate</span> === <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// One of the queues is not empty. We must add the update to both queues.</span>
      <span class="hljs-title function_">appendUpdateToQueue</span>(queue1, update);
      <span class="hljs-title function_">appendUpdateToQueue</span>(queue2, update);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Both queues are non-empty. The last update is the same in both lists,</span>
      <span class="hljs-comment">// because of structural sharing. So, only append to one of the lists.</span>
      <span class="hljs-title function_">appendUpdateToQueue</span>(queue1, update);
      <span class="hljs-comment">// But we still need to update the `lastUpdate` pointer of queue2.</span>
      queue2.<span class="hljs-property">lastUpdate</span> = update;
    }
  }
}
</code></pre>
<h6 id="createupdatequeue">createUpdateQueue</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> createUpdateQueue&#x3C;<span class="hljs-title class_">State</span>>(<span class="hljs-attr">baseState</span>: <span class="hljs-title class_">State</span>): <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>> = {
    baseState,
    <span class="hljs-attr">firstUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">firstCapturedUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastCapturedUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">firstEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">firstCapturedEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastCapturedEffect</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-keyword">return</span> queue;
}
</code></pre>
<h6 id="cloneupdatequeue">cloneUpdateQueue</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">function</span> cloneUpdateQueue&#x3C;<span class="hljs-title class_">State</span>>(
  <span class="hljs-attr">currentQueue</span>: <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>>,
): <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>> = {
    <span class="hljs-attr">baseState</span>: currentQueue.<span class="hljs-property">baseState</span>,
    <span class="hljs-attr">firstUpdate</span>: currentQueue.<span class="hljs-property">firstUpdate</span>,
    <span class="hljs-attr">lastUpdate</span>: currentQueue.<span class="hljs-property">lastUpdate</span>,

    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> With resuming, if we bail out and resuse the child tree, we should</span>
    <span class="hljs-comment">// keep these effects.</span>
    <span class="hljs-attr">firstCapturedUpdate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastCapturedUpdate</span>: <span class="hljs-literal">null</span>,

    <span class="hljs-attr">firstEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastEffect</span>: <span class="hljs-literal">null</span>,

    <span class="hljs-attr">firstCapturedEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">lastCapturedEffect</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-keyword">return</span> queue;
}
</code></pre>
<h6 id="appendupdatetoqueue">appendUpdateToQueue</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">function</span> appendUpdateToQueue&#x3C;<span class="hljs-title class_">State</span>>(
  <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>>,
  <span class="hljs-attr">update</span>: <span class="hljs-title class_">Update</span>&#x3C;<span class="hljs-title class_">State</span>>,
) {
  <span class="hljs-comment">// Append the update to the end of the list.</span>
  <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">lastUpdate</span> === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// Queue is empty</span>
    queue.<span class="hljs-property">firstUpdate</span> = queue.<span class="hljs-property">lastUpdate</span> = update;
  } <span class="hljs-keyword">else</span> {
    queue.<span class="hljs-property">lastUpdate</span>.<span class="hljs-property">next</span> = update;
    queue.<span class="hljs-property">lastUpdate</span> = update;
  }
}
</code></pre>
<h4 id="schedulework">scheduleWork</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">
  fiber: Fiber,
  expirationTime: ExpirationTime,
</span>) {
  <span class="hljs-title function_">checkForNestedUpdates</span>();
  <span class="hljs-title function_">warnAboutInvalidUpdatesOnClassComponentsInDEV</span>(fiber);

  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">markUpdateTimeFromFiberToRoot</span>(fiber, expirationTime);
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
    <span class="hljs-title function_">warnAboutUpdateOnUnmountedFiberInDEV</span>(fiber);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-title function_">checkForInterruption</span>(fiber, expirationTime);
  <span class="hljs-title function_">recordScheduleUpdate</span>();

  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> computeExpirationForFiber also reads the priority. Pass the</span>
  <span class="hljs-comment">// priority as an argument to that function and this one.</span>
  <span class="hljs-keyword">const</span> priorityLevel = <span class="hljs-title function_">getCurrentPriorityLevel</span>();

  <span class="hljs-keyword">if</span> (expirationTime === <span class="hljs-title class_">Sync</span>) {
    <span class="hljs-keyword">if</span> (
      <span class="hljs-comment">// Check if we're inside unbatchedUpdates</span>
      (executionContext &#x26; <span class="hljs-title class_">LegacyUnbatchedContext</span>) !== <span class="hljs-title class_">NoContext</span> &#x26;&#x26;
      <span class="hljs-comment">// Check if we're not already rendering</span>
      (executionContext &#x26; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>
    ) {
      <span class="hljs-comment">// Register pending interactions on the root to avoid losing traced interaction data.</span>
      <span class="hljs-title function_">schedulePendingInteractions</span>(root, expirationTime);

      <span class="hljs-comment">// This is a legacy edge case. The initial mount of a ReactDOM.render-ed</span>
      <span class="hljs-comment">// root inside of batchedUpdates should be synchronous, but layout updates</span>
      <span class="hljs-comment">// should be deferred until the end of the batch.</span>
      <span class="hljs-title function_">performSyncWorkOnRoot</span>(root);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">ensureRootIsScheduled</span>(root);
      <span class="hljs-title function_">schedulePendingInteractions</span>(root, expirationTime);
      <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {
        <span class="hljs-comment">// Flush the synchronous work now, unless we're already working or inside</span>
        <span class="hljs-comment">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span>
        <span class="hljs-comment">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span>
        <span class="hljs-comment">// without immediately flushing it. We only do this for user-initiated</span>
        <span class="hljs-comment">// updates, to preserve historical behavior of sync mode.</span>
        <span class="hljs-title function_">flushSyncCallbackQueue</span>();
      }
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">ensureRootIsScheduled</span>(root);
    <span class="hljs-title function_">schedulePendingInteractions</span>(root, expirationTime);
  }

  <span class="hljs-keyword">if</span> (
    (executionContext &#x26; <span class="hljs-title class_">DiscreteEventContext</span>) !== <span class="hljs-title class_">NoContext</span> &#x26;&#x26;
    <span class="hljs-comment">// Only updates at user-blocking priority or greater are considered</span>
    <span class="hljs-comment">// discrete, even inside a discrete event.</span>
    (priorityLevel === <span class="hljs-title class_">UserBlockingPriority</span> ||
      priorityLevel === <span class="hljs-title class_">ImmediatePriority</span>)
  ) {
    <span class="hljs-comment">// This is the result of a discrete event. Track the lowest priority</span>
    <span class="hljs-comment">// discrete update per root so we can flush them early, if needed.</span>
    <span class="hljs-keyword">if</span> (rootsWithPendingDiscreteUpdates === <span class="hljs-literal">null</span>) {
      rootsWithPendingDiscreteUpdates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[root, expirationTime]]);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> lastDiscreteTime = rootsWithPendingDiscreteUpdates.<span class="hljs-title function_">get</span>(root);
      <span class="hljs-keyword">if</span> (lastDiscreteTime === <span class="hljs-literal">undefined</span> || lastDiscreteTime > expirationTime) {
        rootsWithPendingDiscreteUpdates.<span class="hljs-title function_">set</span>(root, expirationTime);
      }
    }
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> scheduleWork = scheduleUpdateOnFiber;
</code></pre>
<h6 id="checkfornestedupdates">checkForNestedUpdates</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForNestedUpdates</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// nestedUpdateCount默认为0</span>
  <span class="hljs-comment">// NESTED_UPDATE_LIMIT = 50</span>
  <span class="hljs-keyword">if</span> (nestedUpdateCount > <span class="hljs-variable constant_">NESTED_UPDATE_LIMIT</span>) {
    nestedUpdateCount = <span class="hljs-number">0</span>;
    rootWithNestedUpdates = <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h6 id="markupdatetimefromfibertoroot">markUpdateTimeFromFiberToRoot</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>

<span class="hljs-comment">// This is split into a separate function so we can mark a fiber with pending</span>
<span class="hljs-comment">// work without treating it as a typical update that originates from an event;</span>
<span class="hljs-comment">// e.g. retrying a Suspense boundary isn't an update, but it does schedule work</span>
<span class="hljs-comment">// on a fiber.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">markUpdateTimeFromFiberToRoot</span>(<span class="hljs-params">fiber, expirationTime</span>) {
  <span class="hljs-comment">// Update the source fiber's expiration time</span>
  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">expirationTime</span> &#x3C; expirationTime) {
    fiber.<span class="hljs-property">expirationTime</span> = expirationTime;
  }
  <span class="hljs-keyword">let</span> alternate = fiber.<span class="hljs-property">alternate</span>;
  <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &#x26;&#x26; alternate.<span class="hljs-property">expirationTime</span> &#x3C; expirationTime) {
    alternate.<span class="hljs-property">expirationTime</span> = expirationTime;
  }
  <span class="hljs-comment">// Walk the parent path to the root and update the child expiration time.</span>
  <span class="hljs-keyword">let</span> node = fiber.<span class="hljs-property">return</span>;
  <span class="hljs-keyword">let</span> root = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span> &#x26;&#x26; fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span>) {
    root = fiber.<span class="hljs-property">stateNode</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
      alternate = node.<span class="hljs-property">alternate</span>;
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">childExpirationTime</span> &#x3C; expirationTime) {
        node.<span class="hljs-property">childExpirationTime</span> = expirationTime;
        <span class="hljs-keyword">if</span> (
          alternate !== <span class="hljs-literal">null</span> &#x26;&#x26;
          alternate.<span class="hljs-property">childExpirationTime</span> &#x3C; expirationTime
        ) {
          alternate.<span class="hljs-property">childExpirationTime</span> = expirationTime;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
        alternate !== <span class="hljs-literal">null</span> &#x26;&#x26;
        alternate.<span class="hljs-property">childExpirationTime</span> &#x3C; expirationTime
      ) {
        alternate.<span class="hljs-property">childExpirationTime</span> = expirationTime;
      }
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> &#x26;&#x26; node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span>) {
        root = node.<span class="hljs-property">stateNode</span>;
        <span class="hljs-keyword">break</span>;
      }
      node = node.<span class="hljs-property">return</span>;
    }
  }

  <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (workInProgressRoot === root) {
      <span class="hljs-comment">// Received an update to a tree that's in the middle of rendering. Mark</span>
      <span class="hljs-comment">// that's unprocessed work on this root.</span>
      <span class="hljs-title function_">markUnprocessedUpdateTime</span>(expirationTime);

      <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootSuspendedWithDelay</span>) {
        <span class="hljs-comment">// The root already suspended with a delay, which means this render</span>
        <span class="hljs-comment">// definitely won't finish. Since we have a new update, let's mark it as</span>
        <span class="hljs-comment">// suspended now, right before marking the incoming update. This has the</span>
        <span class="hljs-comment">// effect of interrupting the current render and switching to the update.</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This happens to work when receiving an update during the render</span>
        <span class="hljs-comment">// phase, because of the trick inside computeExpirationForFiber to</span>
        <span class="hljs-comment">// subtract 1 from `renderExpirationTime` to move it into a</span>
        <span class="hljs-comment">// separate bucket. But we should probably model it with an exception,</span>
        <span class="hljs-comment">// using the same mechanism we use to force hydration of a subtree.</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This does not account for low pri updates that were already</span>
        <span class="hljs-comment">// scheduled before the root started rendering. Need to track the next</span>
        <span class="hljs-comment">// pending expiration time (perhaps by backtracking the return path) and</span>
        <span class="hljs-comment">// then trigger a restart in the `renderDidSuspendDelayIfPossible` path.</span>
        <span class="hljs-title function_">markRootSuspendedAtTime</span>(root, renderExpirationTime);
      }
    }
    <span class="hljs-comment">// Mark that the root has a pending update.</span>
    <span class="hljs-title function_">markRootUpdatedAtTime</span>(root, expirationTime);
  }

  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<p>markUnprocessedUpdateTime</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">markUnprocessedUpdateTime</span>(<span class="hljs-params">
  expirationTime: ExpirationTime,
</span>): <span class="hljs-keyword">void</span> {
  <span class="hljs-keyword">if</span> (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {
    workInProgressRootNextUnprocessedUpdateTime = expirationTime;
  }
}
</code></pre>
<p>markRootUpdatedAtTime</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberRoot.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootUpdatedAtTime</span>(<span class="hljs-params">
  root: FiberRoot,
  expirationTime: ExpirationTime,
</span>): <span class="hljs-keyword">void</span> {
  <span class="hljs-comment">// Update the range of pending times</span>
  <span class="hljs-keyword">const</span> firstPendingTime = root.<span class="hljs-property">firstPendingTime</span>;
  <span class="hljs-keyword">if</span> (expirationTime > firstPendingTime) {
    root.<span class="hljs-property">firstPendingTime</span> = expirationTime;
  }

  <span class="hljs-comment">// Update the range of suspended times. Treat everything lower priority or</span>
  <span class="hljs-comment">// equal to this update as unsuspended.</span>
  <span class="hljs-keyword">const</span> firstSuspendedTime = root.<span class="hljs-property">firstSuspendedTime</span>;
  <span class="hljs-keyword">if</span> (firstSuspendedTime !== <span class="hljs-title class_">NoWork</span>) {
    <span class="hljs-keyword">if</span> (expirationTime >= firstSuspendedTime) {
      <span class="hljs-comment">// The entire suspended range is now unsuspended.</span>
      root.<span class="hljs-property">firstSuspendedTime</span> = root.<span class="hljs-property">lastSuspendedTime</span> = root.<span class="hljs-property">nextKnownPendingLevel</span> = <span class="hljs-title class_">NoWork</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expirationTime >= root.<span class="hljs-property">lastSuspendedTime</span>) {
      root.<span class="hljs-property">lastSuspendedTime</span> = expirationTime + <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// This is a pending level. Check if it's higher priority than the next</span>
    <span class="hljs-comment">// known pending level.</span>
    <span class="hljs-keyword">if</span> (expirationTime > root.<span class="hljs-property">nextKnownPendingLevel</span>) {
      root.<span class="hljs-property">nextKnownPendingLevel</span> = expirationTime;
    }
  }
}
</code></pre>
<h6 id="checkforinterruption">checkForInterruption</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForInterruption</span>(<span class="hljs-params">
  fiberThatReceivedUpdate: Fiber,
  updateExpirationTime: ExpirationTime,
</span>) {
  <span class="hljs-keyword">if</span> (
    enableUserTimingAPI &#x26;&#x26;
    workInProgressRoot !== <span class="hljs-literal">null</span> &#x26;&#x26;
    updateExpirationTime > renderExpirationTime
  ) {
    interruptedBy = fiberThatReceivedUpdate;
  }
}
</code></pre>
<h6 id="recordscheduleupdate">recordScheduleUpdate</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactDebugFiberPerf.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">recordScheduleUpdate</span>(<span class="hljs-params"></span>): <span class="hljs-keyword">void</span> {
  <span class="hljs-keyword">if</span> (enableUserTimingAPI) {
    <span class="hljs-keyword">if</span> (isCommitting) {
      hasScheduledUpdateInCurrentCommit = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (
      currentPhase !== <span class="hljs-literal">null</span> &#x26;&#x26;
      currentPhase !== <span class="hljs-string">'componentWillMount'</span> &#x26;&#x26;
      currentPhase !== <span class="hljs-string">'componentWillReceiveProps'</span>
    ) {
      hasScheduledUpdateInCurrentPhase = <span class="hljs-literal">true</span>;
    }
  }
}
</code></pre>
<h6 id="getcurrentprioritylevel">getCurrentPriorityLevel</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\SchedulerWithReactIntegration.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentPriorityLevel</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">ReactPriorityLevel</span> {
  <span class="hljs-keyword">switch</span> (<span class="hljs-title class_">Scheduler</span>_getCurrentPriorityLevel()) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_ImmediatePriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">ImmediatePriority</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_UserBlockingPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserBlockingPriority</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_NormalPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">NormalPriority</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_LowPriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">LowPriority</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_IdlePriority</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdlePriority</span>;
    <span class="hljs-attr">default</span>:
      <span class="hljs-title function_">invariant</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">'Unknown priority level.'</span>);
  }
}
</code></pre>
<h6 id="schedulependinginteractions">schedulePendingInteractions</h6>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">schedulePendingInteractions</span>(<span class="hljs-params">root, expirationTime</span>) {
  <span class="hljs-comment">// This is called when work is scheduled on a root.</span>
  <span class="hljs-comment">// It associates the current interactions with the newly-scheduled expiration.</span>
  <span class="hljs-comment">// They will be restored when that expiration is later committed.</span>
  <span class="hljs-keyword">if</span> (!enableSchedulerTracing) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-title function_">scheduleInteractions</span>(root, expirationTime, __interactionsRef.<span class="hljs-property">current</span>);
}
</code></pre>
<p>scheduleInteractions</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleInteractions</span>(<span class="hljs-params">root, expirationTime, interactions</span>) {
  <span class="hljs-keyword">if</span> (!enableSchedulerTracing) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">if</span> (interactions.<span class="hljs-property">size</span> > <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> pendingInteractionMap = root.<span class="hljs-property">pendingInteractionMap</span>;
    <span class="hljs-keyword">const</span> pendingInteractions = pendingInteractionMap.<span class="hljs-title function_">get</span>(expirationTime);
    <span class="hljs-keyword">if</span> (pendingInteractions != <span class="hljs-literal">null</span>) {
      interactions.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">interaction</span> =></span> {
        <span class="hljs-keyword">if</span> (!pendingInteractions.<span class="hljs-title function_">has</span>(interaction)) {
          <span class="hljs-comment">// Update the pending async work count for previously unscheduled interaction.</span>
          interaction.<span class="hljs-property">__count</span>++;
        }

        pendingInteractions.<span class="hljs-title function_">add</span>(interaction);
      });
    } <span class="hljs-keyword">else</span> {
      pendingInteractionMap.<span class="hljs-title function_">set</span>(expirationTime, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(interactions));

      <span class="hljs-comment">// Update the pending async work count for the current interactions.</span>
      interactions.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">interaction</span> =></span> {
        interaction.<span class="hljs-property">__count</span>++;
      });
    }

    <span class="hljs-keyword">const</span> subscriber = __subscriberRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> threadID = <span class="hljs-title function_">computeThreadID</span>(root, expirationTime);
      subscriber.<span class="hljs-title function_">onWorkScheduled</span>(interactions, threadID);
    }
  }
}
</code></pre>
<h6 id="performsyncworkonroot">performSyncWorkOnRoot</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>

<span class="hljs-comment">// This is the entry point for synchronous tasks that don't go</span>
<span class="hljs-comment">// through Scheduler</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">performSyncWorkOnRoot</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-comment">// Check if there's expired work on this root. Otherwise, render at Sync.</span>
  <span class="hljs-keyword">const</span> lastExpiredTime = root.<span class="hljs-property">lastExpiredTime</span>;
  <span class="hljs-keyword">const</span> expirationTime = lastExpiredTime !== <span class="hljs-title class_">NoWork</span> ? lastExpiredTime : <span class="hljs-title class_">Sync</span>;
  <span class="hljs-keyword">if</span> (root.<span class="hljs-property">finishedExpirationTime</span> === expirationTime) {
    <span class="hljs-comment">// There's already a pending commit at this expiration time.</span>
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This is poorly factored. This case only exists for the</span>
    <span class="hljs-comment">// batch.commit() API.</span>
    <span class="hljs-title function_">commitRoot</span>(root);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">invariant</span>(
      (executionContext &#x26; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>,
      <span class="hljs-string">'Should not already be working.'</span>,
    );

    <span class="hljs-title function_">flushPassiveEffects</span>();

    <span class="hljs-comment">// If the root or expiration time have changed, throw out the existing stack</span>
    <span class="hljs-comment">// and prepare a fresh one. Otherwise we'll continue where we left off.</span>
    <span class="hljs-keyword">if</span> (
      root !== workInProgressRoot ||
      expirationTime !== renderExpirationTime
    ) {
      <span class="hljs-title function_">prepareFreshStack</span>(root, expirationTime);
      <span class="hljs-title function_">startWorkOnPendingInteractions</span>(root, expirationTime);
    }

    <span class="hljs-comment">// If we have a work-in-progress fiber, it means there's still work to do</span>
    <span class="hljs-comment">// in this root.</span>
    <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> prevExecutionContext = executionContext;
      executionContext |= <span class="hljs-title class_">RenderContext</span>;
      <span class="hljs-keyword">const</span> prevDispatcher = <span class="hljs-title function_">pushDispatcher</span>(root);
      <span class="hljs-keyword">const</span> prevInteractions = <span class="hljs-title function_">pushInteractions</span>(root);
      <span class="hljs-title function_">startWorkLoopTimer</span>(workInProgress);

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">workLoopSync</span>();
          <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">catch</span> (thrownValue) {
          <span class="hljs-title function_">handleError</span>(root, thrownValue);
        }
      } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);
      <span class="hljs-title function_">resetContextDependencies</span>();
      executionContext = prevExecutionContext;
      <span class="hljs-title function_">popDispatcher</span>(prevDispatcher);
      <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
        <span class="hljs-title function_">popInteractions</span>(((<span class="hljs-attr">prevInteractions</span>: any): <span class="hljs-title class_">Set</span>&#x3C;<span class="hljs-title class_">Interaction</span>>));
      }

      <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootFatalErrored</span>) {
        <span class="hljs-keyword">const</span> fatalError = workInProgressRootFatalError;
        <span class="hljs-title function_">stopInterruptedWorkLoopTimer</span>();
        <span class="hljs-title function_">prepareFreshStack</span>(root, expirationTime);
        <span class="hljs-title function_">markRootSuspendedAtTime</span>(root, expirationTime);
        <span class="hljs-title function_">ensureRootIsScheduled</span>(root);
        <span class="hljs-keyword">throw</span> fatalError;
      }

      <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// This is a sync render, so we should have finished the whole tree.</span>
        <span class="hljs-title function_">invariant</span>(
          <span class="hljs-literal">false</span>,
          <span class="hljs-string">'Cannot commit an incomplete root. This error is likely caused by a '</span> +
            <span class="hljs-string">'bug in React. Please file an issue.'</span>,
        );
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// We now have a consistent tree. Because this is a sync render, we</span>
        <span class="hljs-comment">// will commit it even if something suspended. The only exception is</span>
        <span class="hljs-comment">// if the root is locked (using the unstable_createBatch API).</span>
        <span class="hljs-title function_">stopFinishedWorkLoopTimer</span>();
        root.<span class="hljs-property">finishedWork</span> = (root.<span class="hljs-property">current</span>.<span class="hljs-property">alternate</span>: any);
        root.<span class="hljs-property">finishedExpirationTime</span> = expirationTime;
        <span class="hljs-title function_">resolveLocksOnRoot</span>(root, expirationTime);
        <span class="hljs-title function_">finishSyncRender</span>(root, workInProgressRootExitStatus, expirationTime);
      }

      <span class="hljs-comment">// Before exiting, make sure there's a callback scheduled for the next</span>
      <span class="hljs-comment">// pending level.</span>
      <span class="hljs-title function_">ensureRootIsScheduled</span>(root);
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<h5 id="preparefreshstack">prepareFreshStack</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareFreshStack</span>(<span class="hljs-params">root, expirationTime</span>) {
  root.<span class="hljs-property">finishedWork</span> = <span class="hljs-literal">null</span>;
  root.<span class="hljs-property">finishedExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-keyword">const</span> timeoutHandle = root.<span class="hljs-property">timeoutHandle</span>;
  <span class="hljs-keyword">if</span> (timeoutHandle !== noTimeout) {
    <span class="hljs-comment">// The root previous suspended and scheduled a timeout to commit a fallback</span>
    <span class="hljs-comment">// state. Now that we have additional work, cancel the timeout.</span>
    root.<span class="hljs-property">timeoutHandle</span> = noTimeout;
    <span class="hljs-comment">// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span>
    <span class="hljs-title function_">cancelTimeout</span>(timeoutHandle);
  }

  <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">let</span> interruptedWork = workInProgress.<span class="hljs-property">return</span>;
    <span class="hljs-keyword">while</span> (interruptedWork !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">unwindInterruptedWork</span>(interruptedWork);
      interruptedWork = interruptedWork.<span class="hljs-property">return</span>;
    }
  }
  workInProgressRoot = root;
  workInProgress = <span class="hljs-title function_">createWorkInProgress</span>(root.<span class="hljs-property">current</span>, <span class="hljs-literal">null</span>, expirationTime);
  renderExpirationTime = expirationTime;
  workInProgressRootExitStatus = <span class="hljs-title class_">RootIncomplete</span>;
  workInProgressRootFatalError = <span class="hljs-literal">null</span>;
  workInProgressRootLatestProcessedExpirationTime = <span class="hljs-title class_">Sync</span>;
  workInProgressRootLatestSuspenseTimeout = <span class="hljs-title class_">Sync</span>;
  workInProgressRootCanSuspendUsingConfig = <span class="hljs-literal">null</span>;
  workInProgressRootNextUnprocessedUpdateTime = <span class="hljs-title class_">NoWork</span>;
  workInProgressRootHasPendingPing = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
    spawnedWorkDuringRender = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">if</span> (__DEV__) {
    <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-title function_">discardPendingWarnings</span>();
    componentsThatTriggeredHighPriSuspend = <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h6 id="createworkinprogress">createWorkInProgress</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiber.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorkInProgress</span>(<span class="hljs-params">
  current: Fiber,
  pendingProps: any,
  expirationTime: ExpirationTime,
</span>): <span class="hljs-title class_">Fiber</span> {
  <span class="hljs-keyword">let</span> workInProgress = current.<span class="hljs-property">alternate</span>;
  <span class="hljs-keyword">if</span> (workInProgress === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// We use a double buffering pooling technique because we know that we'll</span>
    <span class="hljs-comment">// only ever need at most two versions of a tree. We pool the "other" unused</span>
    <span class="hljs-comment">// node that we're free to reuse. This is lazily created to avoid allocating</span>
    <span class="hljs-comment">// extra objects for things that are never updated. It also allow us to</span>
    <span class="hljs-comment">// reclaim the extra memory if needed.</span>
    workInProgress = <span class="hljs-title function_">createFiber</span>(
      current.<span class="hljs-property">tag</span>,
      pendingProps,
      current.<span class="hljs-property">key</span>,
      current.<span class="hljs-property">mode</span>,
    );
    workInProgress.<span class="hljs-property">elementType</span> = current.<span class="hljs-property">elementType</span>;
    workInProgress.<span class="hljs-property">type</span> = current.<span class="hljs-property">type</span>;
    workInProgress.<span class="hljs-property">stateNode</span> = current.<span class="hljs-property">stateNode</span>;

    <span class="hljs-keyword">if</span> (__DEV__) {
      <span class="hljs-comment">// DEV-only fields</span>
      workInProgress.<span class="hljs-property">_debugID</span> = current.<span class="hljs-property">_debugID</span>;
      workInProgress.<span class="hljs-property">_debugSource</span> = current.<span class="hljs-property">_debugSource</span>;
      workInProgress.<span class="hljs-property">_debugOwner</span> = current.<span class="hljs-property">_debugOwner</span>;
      workInProgress.<span class="hljs-property">_debugHookTypes</span> = current.<span class="hljs-property">_debugHookTypes</span>;
    }

    workInProgress.<span class="hljs-property">alternate</span> = current;
    current.<span class="hljs-property">alternate</span> = workInProgress;
  } <span class="hljs-keyword">else</span> {
    workInProgress.<span class="hljs-property">pendingProps</span> = pendingProps;

    <span class="hljs-comment">// We already have an alternate.</span>
    <span class="hljs-comment">// Reset the effect tag.</span>
    workInProgress.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">NoEffect</span>;

    <span class="hljs-comment">// The effect list is no longer valid.</span>
    workInProgress.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
    workInProgress.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;
    workInProgress.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (enableProfilerTimer) {
      <span class="hljs-comment">// We intentionally reset, rather than copy, actualDuration &#x26; actualStartTime.</span>
      <span class="hljs-comment">// This prevents time from endlessly accumulating in new commits.</span>
      <span class="hljs-comment">// This has the downside of resetting values for different priority renders,</span>
      <span class="hljs-comment">// But works for yielding (the common case) and should support resuming.</span>
      workInProgress.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;
      workInProgress.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;
    }
  }

  workInProgress.<span class="hljs-property">childExpirationTime</span> = current.<span class="hljs-property">childExpirationTime</span>;
  workInProgress.<span class="hljs-property">expirationTime</span> = current.<span class="hljs-property">expirationTime</span>;

  workInProgress.<span class="hljs-property">child</span> = current.<span class="hljs-property">child</span>;
  workInProgress.<span class="hljs-property">memoizedProps</span> = current.<span class="hljs-property">memoizedProps</span>;
  workInProgress.<span class="hljs-property">memoizedState</span> = current.<span class="hljs-property">memoizedState</span>;
  workInProgress.<span class="hljs-property">updateQueue</span> = current.<span class="hljs-property">updateQueue</span>;

  <span class="hljs-comment">// Clone the dependencies object. This is mutated during the render phase, so</span>
  <span class="hljs-comment">// it cannot be shared with the current fiber.</span>
  <span class="hljs-keyword">const</span> currentDependencies = current.<span class="hljs-property">dependencies</span>;
  workInProgress.<span class="hljs-property">dependencies</span> =
    currentDependencies === <span class="hljs-literal">null</span>
      ? <span class="hljs-literal">null</span>
      : {
          <span class="hljs-attr">expirationTime</span>: currentDependencies.<span class="hljs-property">expirationTime</span>,
          <span class="hljs-attr">firstContext</span>: currentDependencies.<span class="hljs-property">firstContext</span>,
          <span class="hljs-attr">responders</span>: currentDependencies.<span class="hljs-property">responders</span>,
        };

  <span class="hljs-comment">// These will be overridden during the parent's reconciliation</span>
  workInProgress.<span class="hljs-property">sibling</span> = current.<span class="hljs-property">sibling</span>;
  workInProgress.<span class="hljs-property">index</span> = current.<span class="hljs-property">index</span>;
  workInProgress.<span class="hljs-property">ref</span> = current.<span class="hljs-property">ref</span>;

  <span class="hljs-keyword">if</span> (enableProfilerTimer) {
    workInProgress.<span class="hljs-property">selfBaseDuration</span> = current.<span class="hljs-property">selfBaseDuration</span>;
    workInProgress.<span class="hljs-property">treeBaseDuration</span> = current.<span class="hljs-property">treeBaseDuration</span>;
  }

  <span class="hljs-keyword">if</span> (__DEV__) {
    workInProgress.<span class="hljs-property">_debugNeedsRemount</span> = current.<span class="hljs-property">_debugNeedsRemount</span>;
    <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
        workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title function_">resolveFunctionForHotReloading</span>(current.<span class="hljs-property">type</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title function_">resolveClassForHotReloading</span>(current.<span class="hljs-property">type</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
        workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title function_">resolveForwardRefForHotReloading</span>(current.<span class="hljs-property">type</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">return</span> workInProgress;
}
</code></pre>
<h6 id="pushdispatcher">pushDispatcher</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pushDispatcher</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">const</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span>;
  <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = <span class="hljs-title class_">ContextOnlyDispatcher</span>;
  <span class="hljs-keyword">if</span> (prevDispatcher === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// The React isomorphic package does not include a default dispatcher.</span>
    <span class="hljs-comment">// Instead the first renderer will lazily attach one, in order to give</span>
    <span class="hljs-comment">// nicer error messages.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ContextOnlyDispatcher</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> prevDispatcher;
  }
}
</code></pre>
<h6 id="workloopsync">workLoopSync</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopSync</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Already timed out, so perform work without checking if we need to yield.</span>
  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>) {
    workInProgress = <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);
  }
}
</code></pre>
<h6 id="performunitofwork">performUnitOfWork</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-comment">// The current, flushed, state of this fiber is the alternate. Ideally</span>
  <span class="hljs-comment">// nothing should rely on this, but relying on it here means that we don't</span>
  <span class="hljs-comment">// need an additional field on the work in progress.</span>
  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;

  <span class="hljs-title function_">startWorkTimer</span>(unitOfWork);
  <span class="hljs-title function_">setCurrentDebugFiberInDEV</span>(unitOfWork);

  <span class="hljs-keyword">let</span> next;
  <span class="hljs-keyword">if</span> (enableProfilerTimer &#x26;&#x26; (unitOfWork.<span class="hljs-property">mode</span> &#x26; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) {
    <span class="hljs-title function_">startProfilerTimer</span>(unitOfWork);
    next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, renderExpirationTime);
    <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(unitOfWork, <span class="hljs-literal">true</span>);
  } <span class="hljs-keyword">else</span> {
    next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, renderExpirationTime);
  }

  <span class="hljs-title function_">resetCurrentDebugFiberInDEV</span>();
  unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;
  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// If this doesn't spawn new work, complete the current work.</span>
    next = <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);
  }

  <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> next;
}
</code></pre>
<h4 id="beginwork">beginWork</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params">
  current: Fiber | <span class="hljs-literal">null</span>,
  workInProgress: Fiber,
  renderExpirationTime: ExpirationTime,
</span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">const</span> updateExpirationTime = workInProgress.<span class="hljs-property">expirationTime</span>;

  <span class="hljs-keyword">if</span> (__DEV__) {
    <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">_debugNeedsRemount</span> &#x26;&#x26; current !== <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// This will restart the begin phase with a new fiber.</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">remountFiber</span>(
        current,
        workInProgress,
        <span class="hljs-title function_">createFiberFromTypeAndProps</span>(
          workInProgress.<span class="hljs-property">type</span>,
          workInProgress.<span class="hljs-property">key</span>,
          workInProgress.<span class="hljs-property">pendingProps</span>,
          workInProgress.<span class="hljs-property">_debugOwner</span> || <span class="hljs-literal">null</span>,
          workInProgress.<span class="hljs-property">mode</span>,
          workInProgress.<span class="hljs-property">expirationTime</span>,
        ),
      );
    }
  }

  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;
    <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;

    <span class="hljs-keyword">if</span> (
      oldProps !== newProps ||
      <span class="hljs-title function_">hasLegacyContextChanged</span>() ||
      <span class="hljs-comment">// Force a re-render if the implementation changed due to hot reload:</span>
      (__DEV__ ? workInProgress.<span class="hljs-property">type</span> !== current.<span class="hljs-property">type</span> : <span class="hljs-literal">false</span>)
    ) {
      <span class="hljs-comment">// If props or context changed, mark the fiber as having performed work.</span>
      <span class="hljs-comment">// This may be unset if the props are determined to be equal later (memo).</span>
      didReceiveUpdate = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (updateExpirationTime &#x3C; renderExpirationTime) {
      didReceiveUpdate = <span class="hljs-literal">false</span>;
      <span class="hljs-comment">// This fiber does not have any pending work. Bailout without entering</span>
      <span class="hljs-comment">// the begin phase. There's still some bookkeeping we that needs to be done</span>
      <span class="hljs-comment">// in this optimized path, mostly pushing stuff onto the stack.</span>
      <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
          <span class="hljs-title function_">pushHostRootContext</span>(workInProgress);
          <span class="hljs-title function_">resetHydrationState</span>();
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
          <span class="hljs-title function_">pushHostContext</span>(workInProgress);
          <span class="hljs-keyword">if</span> (
            workInProgress.<span class="hljs-property">mode</span> &#x26; <span class="hljs-title class_">ConcurrentMode</span> &#x26;&#x26;
            renderExpirationTime !== <span class="hljs-title class_">Never</span> &#x26;&#x26;
            <span class="hljs-title function_">shouldDeprioritizeSubtree</span>(workInProgress.<span class="hljs-property">type</span>, newProps)
          ) {
            <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
              <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">Never</span>);
            }
            <span class="hljs-comment">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span>
            workInProgress.<span class="hljs-property">expirationTime</span> = workInProgress.<span class="hljs-property">childExpirationTime</span> = <span class="hljs-title class_">Never</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: {
          <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isLegacyContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
            <span class="hljs-title function_">pushLegacyContextProvider</span>(workInProgress);
          }
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
          <span class="hljs-title function_">pushHostContainer</span>(
            workInProgress,
            workInProgress.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>,
          );
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextProvider</span>: {
          <span class="hljs-keyword">const</span> newValue = workInProgress.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">value</span>;
          <span class="hljs-title function_">pushProvider</span>(workInProgress, newValue);
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">Profiler</span>:
          <span class="hljs-keyword">if</span> (enableProfilerTimer) {
            workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Update</span>;
          }
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>: {
          <span class="hljs-keyword">const</span> <span class="hljs-attr">state</span>: <span class="hljs-title class_">SuspenseState</span> | <span class="hljs-literal">null</span> = workInProgress.<span class="hljs-property">memoizedState</span>;
          <span class="hljs-keyword">if</span> (state !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (enableSuspenseServerRenderer) {
              <span class="hljs-keyword">if</span> (state.<span class="hljs-property">dehydrated</span> !== <span class="hljs-literal">null</span>) {
                <span class="hljs-title function_">pushSuspenseContext</span>(
                  workInProgress,
                  <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>),
                );
                <span class="hljs-comment">// We know that this component will suspend again because if it has</span>
                <span class="hljs-comment">// been unsuspended it has committed as a resolved Suspense component.</span>
                <span class="hljs-comment">// If it needs to be retried, it should have work scheduled on it.</span>
                workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">DidCapture</span>;
                <span class="hljs-keyword">break</span>;
              }
            }

            <span class="hljs-comment">// If this boundary is currently timed out, we need to decide</span>
            <span class="hljs-comment">// whether to retry the primary children, or to skip over it and</span>
            <span class="hljs-comment">// go straight to the fallback. Check the priority of the primary</span>
            <span class="hljs-comment">// child fragment.</span>
            <span class="hljs-keyword">const</span> <span class="hljs-attr">primaryChildFragment</span>: <span class="hljs-title class_">Fiber</span> = (workInProgress.<span class="hljs-property">child</span>: any);
            <span class="hljs-keyword">const</span> primaryChildExpirationTime =
              primaryChildFragment.<span class="hljs-property">childExpirationTime</span>;
            <span class="hljs-keyword">if</span> (
              primaryChildExpirationTime !== <span class="hljs-title class_">NoWork</span> &#x26;&#x26;
              primaryChildExpirationTime >= renderExpirationTime
            ) {
              <span class="hljs-comment">// The primary children have pending work. Use the normal path</span>
              <span class="hljs-comment">// to attempt to render the primary children again.</span>
              <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSuspenseComponent</span>(
                current,
                workInProgress,
                renderExpirationTime,
              );
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-title function_">pushSuspenseContext</span>(
                workInProgress,
                <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>),
              );
              <span class="hljs-comment">// The primary children do not have pending work with sufficient</span>
              <span class="hljs-comment">// priority. Bailout.</span>
              <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(
                current,
                workInProgress,
                renderExpirationTime,
              );
              <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// The fallback children have pending work. Skip over the</span>
                <span class="hljs-comment">// primary children and work on the fallback.</span>
                <span class="hljs-keyword">return</span> child.<span class="hljs-property">sibling</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">pushSuspenseContext</span>(
              workInProgress,
              <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>),
            );
          }
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>: {
          <span class="hljs-keyword">const</span> didSuspendBefore =
            (current.<span class="hljs-property">effectTag</span> &#x26; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoEffect</span>;

          <span class="hljs-keyword">const</span> hasChildWork =
            workInProgress.<span class="hljs-property">childExpirationTime</span> >= renderExpirationTime;

          <span class="hljs-keyword">if</span> (didSuspendBefore) {
            <span class="hljs-keyword">if</span> (hasChildWork) {
              <span class="hljs-comment">// If something was in fallback state last time, and we have all the</span>
              <span class="hljs-comment">// same children then we're still in progressive loading state.</span>
              <span class="hljs-comment">// Something might get unblocked by state updates or retries in the</span>
              <span class="hljs-comment">// tree which will affect the tail. So we need to use the normal</span>
              <span class="hljs-comment">// path to compute the correct tail.</span>
              <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSuspenseListComponent</span>(
                current,
                workInProgress,
                renderExpirationTime,
              );
            }
            <span class="hljs-comment">// If none of the children had any work, that means that none of</span>
            <span class="hljs-comment">// them got retried so they'll still be blocked in the same way</span>
            <span class="hljs-comment">// as before. We can fast bail out.</span>
            workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">DidCapture</span>;
          }

          <span class="hljs-comment">// If nothing suspended before and we're rendering the same children,</span>
          <span class="hljs-comment">// then the tail doesn't matter. Anything new that suspends will work</span>
          <span class="hljs-comment">// in the "together" mode, so we can continue from the state we had.</span>
          <span class="hljs-keyword">let</span> renderState = workInProgress.<span class="hljs-property">memoizedState</span>;
          <span class="hljs-keyword">if</span> (renderState !== <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// Reset to the "together" mode in case we've started a different</span>
            <span class="hljs-comment">// update in the past but didn't complete it.</span>
            renderState.<span class="hljs-property">rendering</span> = <span class="hljs-literal">null</span>;
            renderState.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>;
          }
          <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, suspenseStackCursor.<span class="hljs-property">current</span>);

          <span class="hljs-keyword">if</span> (hasChildWork) {
            <span class="hljs-keyword">break</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// If none of the children had any work, that means that none of</span>
            <span class="hljs-comment">// them got retried so they'll still be blocked in the same way</span>
            <span class="hljs-comment">// as before. We can fast bail out.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(
        current,
        workInProgress,
        renderExpirationTime,
      );
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// An update was scheduled on this fiber, but there are no new props</span>
      <span class="hljs-comment">// nor legacy context. Set this to false. If an update queue or context</span>
      <span class="hljs-comment">// consumer produces a changed value, it will set this to true. Otherwise,</span>
      <span class="hljs-comment">// the component will assume the children have not changed and bail out.</span>
      didReceiveUpdate = <span class="hljs-literal">false</span>;
    }
  } <span class="hljs-keyword">else</span> {
    didReceiveUpdate = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Before entering the begin phase, clear the expiration time.</span>
  workInProgress.<span class="hljs-property">expirationTime</span> = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>: {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountIndeterminateComponent</span>(
        current,
        workInProgress,
        workInProgress.<span class="hljs-property">type</span>,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LazyComponent</span>: {
      <span class="hljs-keyword">const</span> elementType = workInProgress.<span class="hljs-property">elementType</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountLazyComponent</span>(
        current,
        workInProgress,
        elementType,
        updateExpirationTime,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: {
      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;
      <span class="hljs-keyword">const</span> resolvedProps =
        workInProgress.<span class="hljs-property">elementType</span> === <span class="hljs-title class_">Component</span>
          ? unresolvedProps
          : <span class="hljs-title function_">resolveDefaultProps</span>(<span class="hljs-title class_">Component</span>, unresolvedProps);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFunctionComponent</span>(
        current,
        workInProgress,
        <span class="hljs-title class_">Component</span>,
        resolvedProps,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: {
      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;
      <span class="hljs-keyword">const</span> resolvedProps =
        workInProgress.<span class="hljs-property">elementType</span> === <span class="hljs-title class_">Component</span>
          ? unresolvedProps
          : <span class="hljs-title function_">resolveDefaultProps</span>(<span class="hljs-title class_">Component</span>, unresolvedProps);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateClassComponent</span>(
        current,
        workInProgress,
        <span class="hljs-title class_">Component</span>,
        resolvedProps,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostRoot</span>(current, workInProgress, renderExpirationTime);
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostComponent</span>(current, workInProgress, renderExpirationTime);
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostText</span>(current, workInProgress);
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSuspenseComponent</span>(
        current,
        workInProgress,
        renderExpirationTime,
      );
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updatePortalComponent</span>(
        current,
        workInProgress,
        renderExpirationTime,
      );
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>: {
      <span class="hljs-keyword">const</span> type = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;
      <span class="hljs-keyword">const</span> resolvedProps =
        workInProgress.<span class="hljs-property">elementType</span> === type
          ? unresolvedProps
          : <span class="hljs-title function_">resolveDefaultProps</span>(type, unresolvedProps);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateForwardRef</span>(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Fragment</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFragment</span>(current, workInProgress, renderExpirationTime);
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Mode</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMode</span>(current, workInProgress, renderExpirationTime);
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Profiler</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateProfiler</span>(current, workInProgress, renderExpirationTime);
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextProvider</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateContextProvider</span>(
        current,
        workInProgress,
        renderExpirationTime,
      );
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextConsumer</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateContextConsumer</span>(
        current,
        workInProgress,
        renderExpirationTime,
      );
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>: {
      <span class="hljs-keyword">const</span> type = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;
      <span class="hljs-comment">// Resolve outer props first, then resolve inner props.</span>
      <span class="hljs-keyword">let</span> resolvedProps = <span class="hljs-title function_">resolveDefaultProps</span>(type, unresolvedProps);
      <span class="hljs-keyword">if</span> (__DEV__) {
        <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">type</span> !== workInProgress.<span class="hljs-property">elementType</span>) {
          <span class="hljs-keyword">const</span> outerPropTypes = type.<span class="hljs-property">propTypes</span>;
          <span class="hljs-keyword">if</span> (outerPropTypes) {
            <span class="hljs-title function_">checkPropTypes</span>(
              outerPropTypes,
              resolvedProps, <span class="hljs-comment">// Resolved for outer only</span>
              <span class="hljs-string">'prop'</span>,
              <span class="hljs-title function_">getComponentName</span>(type),
              getCurrentFiberStackInDev,
            );
          }
        }
      }
      resolvedProps = <span class="hljs-title function_">resolveDefaultProps</span>(type.<span class="hljs-property">type</span>, resolvedProps);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMemoComponent</span>(
        current,
        workInProgress,
        type,
        resolvedProps,
        updateExpirationTime,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>: {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSimpleMemoComponent</span>(
        current,
        workInProgress,
        workInProgress.<span class="hljs-property">type</span>,
        workInProgress.<span class="hljs-property">pendingProps</span>,
        updateExpirationTime,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IncompleteClassComponent</span>: {
      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;
      <span class="hljs-keyword">const</span> resolvedProps =
        workInProgress.<span class="hljs-property">elementType</span> === <span class="hljs-title class_">Component</span>
          ? unresolvedProps
          : <span class="hljs-title function_">resolveDefaultProps</span>(<span class="hljs-title class_">Component</span>, unresolvedProps);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountIncompleteClassComponent</span>(
        current,
        workInProgress,
        <span class="hljs-title class_">Component</span>,
        resolvedProps,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>: {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSuspenseListComponent</span>(
        current,
        workInProgress,
        renderExpirationTime,
      );
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FundamentalComponent</span>: {
      <span class="hljs-keyword">if</span> (enableFundamentalAPI) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFundamentalComponent</span>(
          current,
          workInProgress,
          renderExpirationTime,
        );
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>: {
      <span class="hljs-keyword">if</span> (enableScopeAPI) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateScopeComponent</span>(
          current,
          workInProgress,
          renderExpirationTime,
        );
      }
      <span class="hljs-keyword">break</span>;
    }
  }
  <span class="hljs-title function_">invariant</span>(
    <span class="hljs-literal">false</span>,
    <span class="hljs-string">'Unknown unit of work tag (%s). This error is likely caused by a bug in '</span> +
      <span class="hljs-string">'React. Please file an issue.'</span>,
    workInProgress.<span class="hljs-property">tag</span>,
  );
}
</code></pre>
<h5 id="updatehostroot">updateHostRoot</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateHostRoot</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) {
  <span class="hljs-title function_">pushHostRootContext</span>(workInProgress);
  <span class="hljs-keyword">const</span> updateQueue = workInProgress.<span class="hljs-property">updateQueue</span>;
  <span class="hljs-title function_">invariant</span>(
    updateQueue !== <span class="hljs-literal">null</span>,
    <span class="hljs-string">'If the root does not have an updateQueue, we should have already '</span> +
      <span class="hljs-string">'bailed out. This error is likely caused by a bug in React. Please '</span> +
      <span class="hljs-string">'file an issue.'</span>,
  );
  <span class="hljs-keyword">const</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>;
  <span class="hljs-keyword">const</span> prevState = workInProgress.<span class="hljs-property">memoizedState</span>;
  <span class="hljs-keyword">const</span> prevChildren = prevState !== <span class="hljs-literal">null</span> ? prevState.<span class="hljs-property">element</span> : <span class="hljs-literal">null</span>;
  <span class="hljs-title function_">processUpdateQueue</span>(
    workInProgress,
    updateQueue,
    nextProps,
    <span class="hljs-literal">null</span>,
    renderExpirationTime,
  );
  <span class="hljs-keyword">const</span> nextState = workInProgress.<span class="hljs-property">memoizedState</span>;
  <span class="hljs-comment">// Caution: React DevTools currently depends on this property</span>
  <span class="hljs-comment">// being called "element".</span>
  <span class="hljs-keyword">const</span> nextChildren = nextState.<span class="hljs-property">element</span>;
  <span class="hljs-keyword">if</span> (nextChildren === prevChildren) {
    <span class="hljs-comment">// If the state is the same as before, that's a bailout because we had</span>
    <span class="hljs-comment">// no work that expires at this time.</span>
    <span class="hljs-title function_">resetHydrationState</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(
      current,
      workInProgress,
      renderExpirationTime,
    );
  }
  <span class="hljs-keyword">const</span> <span class="hljs-attr">root</span>: <span class="hljs-title class_">FiberRoot</span> = workInProgress.<span class="hljs-property">stateNode</span>;
  <span class="hljs-keyword">if</span> (root.<span class="hljs-property">hydrate</span> &#x26;&#x26; <span class="hljs-title function_">enterHydrationState</span>(workInProgress)) {
    <span class="hljs-comment">// If we don't have any current children this might be the first pass.</span>
    <span class="hljs-comment">// We always try to hydrate. If this isn't a hydration pass there won't</span>
    <span class="hljs-comment">// be any children to hydrate which is effectively the same thing as</span>
    <span class="hljs-comment">// not hydrating.</span>

    <span class="hljs-keyword">let</span> child = <span class="hljs-title function_">mountChildFibers</span>(
      workInProgress,
      <span class="hljs-literal">null</span>,
      nextChildren,
      renderExpirationTime,
    );
    workInProgress.<span class="hljs-property">child</span> = child;

    <span class="hljs-keyword">let</span> node = child;
    <span class="hljs-keyword">while</span> (node) {
      <span class="hljs-comment">// Mark each child as hydrating. This is a fast path to know whether this</span>
      <span class="hljs-comment">// tree is part of a hydrating tree. This is used to determine if a child</span>
      <span class="hljs-comment">// node has fully mounted yet, and for scheduling event replaying.</span>
      <span class="hljs-comment">// Conceptually this is similar to Placement in that a new subtree is</span>
      <span class="hljs-comment">// inserted into the React tree here. It just happens to not need DOM</span>
      <span class="hljs-comment">// mutations because it already exists.</span>
      node.<span class="hljs-property">effectTag</span> = (node.<span class="hljs-property">effectTag</span> &#x26; ~<span class="hljs-title class_">Placement</span>) | <span class="hljs-title class_">Hydrating</span>;
      node = node.<span class="hljs-property">sibling</span>;
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Otherwise reset hydration state in case we aborted and resumed another</span>
    <span class="hljs-comment">// root.</span>
    <span class="hljs-title function_">reconcileChildren</span>(
      current,
      workInProgress,
      nextChildren,
      renderExpirationTime,
    );
    <span class="hljs-title function_">resetHydrationState</span>();
  }
  <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
}
</code></pre>
<h6 id="pushhostrootcontext">pushHostRootContext</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">pushHostRootContext</span>(<span class="hljs-params">workInProgress</span>) {
  <span class="hljs-keyword">const</span> root = (workInProgress.<span class="hljs-property">stateNode</span>: <span class="hljs-title class_">FiberRoot</span>);
  <span class="hljs-keyword">if</span> (root.<span class="hljs-property">pendingContext</span>) {
    <span class="hljs-title function_">pushTopLevelContextObject</span>(
      workInProgress,
      root.<span class="hljs-property">pendingContext</span>,
      root.<span class="hljs-property">pendingContext</span> !== root.<span class="hljs-property">context</span>,
    );
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.<span class="hljs-property">context</span>) {
    <span class="hljs-comment">// Should always be set</span>
    <span class="hljs-title function_">pushTopLevelContextObject</span>(workInProgress, root.<span class="hljs-property">context</span>, <span class="hljs-literal">false</span>);
  }
  <span class="hljs-title function_">pushHostContainer</span>(workInProgress, root.<span class="hljs-property">containerInfo</span>);
}
</code></pre>
<h6 id="pushtoplevelcontextobject">pushTopLevelContextObject</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberContext.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTopLevelContextObject</span>(<span class="hljs-params">
  fiber: Fiber,
  context: <span class="hljs-built_in">Object</span>,
  didChange: boolean,
</span>): <span class="hljs-keyword">void</span> {
  <span class="hljs-keyword">if</span> (disableLegacyContext) {
    <span class="hljs-keyword">return</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">invariant</span>(
      contextStackCursor.<span class="hljs-property">current</span> === emptyContextObject,
      <span class="hljs-string">'Unexpected context found on stack. '</span> +
        <span class="hljs-string">'This error is likely caused by a bug in React. Please file an issue.'</span>,
    );
	<span class="hljs-comment">// contextStackCursor默认为createCursor(emptyContextObject)，其中emptyContextObject = {}</span>
	<span class="hljs-comment">// function createCursor&#x3C;T>(defaultValue: T): StackCursor&#x3C;T> {</span>
    <span class="hljs-comment">//   return {</span>
    <span class="hljs-comment">//     current: defaultValue,</span>
    <span class="hljs-comment">//   };</span>
	<span class="hljs-comment">// }</span>
    <span class="hljs-title function_">push</span>(contextStackCursor, context, fiber);
    <span class="hljs-title function_">push</span>(didPerformWorkStackCursor, didChange, fiber);
  }
}
</code></pre>
<h6 id="push">push</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberStack.js</span>
<span class="hljs-keyword">function</span> push&#x3C;T>(<span class="hljs-attr">cursor</span>: <span class="hljs-title class_">StackCursor</span>&#x3C;T>, <span class="hljs-attr">value</span>: T, <span class="hljs-attr">fiber</span>: <span class="hljs-title class_">Fiber</span>): <span class="hljs-keyword">void</span> {
  <span class="hljs-comment">// 默认index = -1</span>
  index++;
  <span class="hljs-comment">// 默认valueStack = []</span>
  valueStack[index] = cursor.<span class="hljs-property">current</span>;

  <span class="hljs-keyword">if</span> (__DEV__) {
    fiberStack[index] = fiber;
  }

  cursor.<span class="hljs-property">current</span> = value;
}
</code></pre>
<h6 id="pushhostcontainer">pushHostContainer</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberHostContext.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pushHostContainer</span>(<span class="hljs-params">fiber: Fiber, nextRootInstance: Container</span>) {
  <span class="hljs-comment">// Push current root instance onto the stack;</span>
  <span class="hljs-comment">// This allows us to reset root when portals are popped.</span>
  <span class="hljs-title function_">push</span>(rootInstanceStackCursor, nextRootInstance, fiber);
  <span class="hljs-comment">// Track the context and the Fiber that provided it.</span>
  <span class="hljs-comment">// This enables us to pop only Fibers that provide unique contexts.</span>
  <span class="hljs-title function_">push</span>(contextFiberStackCursor, fiber, fiber);

  <span class="hljs-comment">// Finally, we need to push the host context to the stack.</span>
  <span class="hljs-comment">// However, we can't just call getRootHostContext() and push it because</span>
  <span class="hljs-comment">// we'd have a different number of entries on the stack depending on</span>
  <span class="hljs-comment">// whether getRootHostContext() throws somewhere in renderer code or not.</span>
  <span class="hljs-comment">// So we push an empty value first. This lets us safely unwind on errors.</span>
  <span class="hljs-title function_">push</span>(contextStackCursor, <span class="hljs-variable constant_">NO_CONTEXT</span>, fiber);
  <span class="hljs-keyword">const</span> nextRootContext = <span class="hljs-title function_">getRootHostContext</span>(nextRootInstance);
  <span class="hljs-comment">// Now that we know this function doesn't throw, replace it.</span>
  <span class="hljs-title function_">pop</span>(contextStackCursor, fiber);
  <span class="hljs-title function_">push</span>(contextStackCursor, nextRootContext, fiber);
}
</code></pre>
<h5 id="processupdatequeue">processUpdateQueue</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> processUpdateQueue&#x3C;<span class="hljs-title class_">State</span>>(
  <span class="hljs-attr">workInProgress</span>: <span class="hljs-title class_">Fiber</span>,
  <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>>,
  <span class="hljs-attr">props</span>: any,
  <span class="hljs-attr">instance</span>: any,
  <span class="hljs-attr">renderExpirationTime</span>: <span class="hljs-title class_">ExpirationTime</span>,
): <span class="hljs-keyword">void</span> {
  hasForceUpdate = <span class="hljs-literal">false</span>;

  queue = <span class="hljs-title function_">ensureWorkInProgressQueueIsAClone</span>(workInProgress, queue);

  <span class="hljs-keyword">if</span> (__DEV__) {
    currentlyProcessingQueue = queue;
  }

  <span class="hljs-comment">// These values may change as we process the queue.</span>
  <span class="hljs-keyword">let</span> newBaseState = queue.<span class="hljs-property">baseState</span>;
  <span class="hljs-keyword">let</span> newFirstUpdate = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> newExpirationTime = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-comment">// Iterate through the list of updates to compute the result.</span>
  <span class="hljs-keyword">let</span> update = queue.<span class="hljs-property">firstUpdate</span>;
  <span class="hljs-keyword">let</span> resultState = newBaseState;
  <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> updateExpirationTime = update.<span class="hljs-property">expirationTime</span>;
    <span class="hljs-keyword">if</span> (updateExpirationTime &#x3C; renderExpirationTime) {
      <span class="hljs-comment">// This update does not have sufficient priority. Skip it.</span>
      <span class="hljs-keyword">if</span> (newFirstUpdate === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// This is the first skipped update. It will be the first update in</span>
        <span class="hljs-comment">// the new list.</span>
        newFirstUpdate = update;
        <span class="hljs-comment">// Since this is the first update that was skipped, the current result</span>
        <span class="hljs-comment">// is the new base state.</span>
        newBaseState = resultState;
      }
      <span class="hljs-comment">// Since this update will remain in the list, update the remaining</span>
      <span class="hljs-comment">// expiration time.</span>
      <span class="hljs-keyword">if</span> (newExpirationTime &#x3C; updateExpirationTime) {
        newExpirationTime = updateExpirationTime;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// This update does have sufficient priority.</span>

      <span class="hljs-comment">// Mark the event time of this update as relevant to this render pass.</span>
      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This should ideally use the true event time of this update rather than</span>
      <span class="hljs-comment">// its priority which is a derived and not reverseable value.</span>
      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> We should skip this update if it was already committed but currently</span>
      <span class="hljs-comment">// we have no way of detecting the difference between a committed and suspended</span>
      <span class="hljs-comment">// update here.</span>
      <span class="hljs-title function_">markRenderEventTimeAndConfig</span>(updateExpirationTime, update.<span class="hljs-property">suspenseConfig</span>);

      <span class="hljs-comment">// Process it and compute a new result.</span>
      resultState = <span class="hljs-title function_">getStateFromUpdate</span>(
        workInProgress,
        queue,
        update,
        resultState,
        props,
        instance,
      );
      <span class="hljs-keyword">const</span> callback = update.<span class="hljs-property">callback</span>;
      <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
        workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Callback</span>;
        <span class="hljs-comment">// Set this to null, in case it was mutated during an aborted render.</span>
        update.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">lastEffect</span> === <span class="hljs-literal">null</span>) {
          queue.<span class="hljs-property">firstEffect</span> = queue.<span class="hljs-property">lastEffect</span> = update;
        } <span class="hljs-keyword">else</span> {
          queue.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = update;
          queue.<span class="hljs-property">lastEffect</span> = update;
        }
      }
    }
    <span class="hljs-comment">// Continue to the next update.</span>
    update = update.<span class="hljs-property">next</span>;
  }

  <span class="hljs-comment">// Separately, iterate though the list of captured updates.</span>
  <span class="hljs-keyword">let</span> newFirstCapturedUpdate = <span class="hljs-literal">null</span>;
  update = queue.<span class="hljs-property">firstCapturedUpdate</span>;
  <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> updateExpirationTime = update.<span class="hljs-property">expirationTime</span>;
    <span class="hljs-keyword">if</span> (updateExpirationTime &#x3C; renderExpirationTime) {
      <span class="hljs-comment">// This update does not have sufficient priority. Skip it.</span>
      <span class="hljs-keyword">if</span> (newFirstCapturedUpdate === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// This is the first skipped captured update. It will be the first</span>
        <span class="hljs-comment">// update in the new list.</span>
        newFirstCapturedUpdate = update;
        <span class="hljs-comment">// If this is the first update that was skipped, the current result is</span>
        <span class="hljs-comment">// the new base state.</span>
        <span class="hljs-keyword">if</span> (newFirstUpdate === <span class="hljs-literal">null</span>) {
          newBaseState = resultState;
        }
      }
      <span class="hljs-comment">// Since this update will remain in the list, update the remaining</span>
      <span class="hljs-comment">// expiration time.</span>
      <span class="hljs-keyword">if</span> (newExpirationTime &#x3C; updateExpirationTime) {
        newExpirationTime = updateExpirationTime;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// This update does have sufficient priority. Process it and compute</span>
      <span class="hljs-comment">// a new result.</span>
      resultState = <span class="hljs-title function_">getStateFromUpdate</span>(
        workInProgress,
        queue,
        update,
        resultState,
        props,
        instance,
      );
      <span class="hljs-keyword">const</span> callback = update.<span class="hljs-property">callback</span>;
      <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
        workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Callback</span>;
        <span class="hljs-comment">// Set this to null, in case it was mutated during an aborted render.</span>
        update.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">lastCapturedEffect</span> === <span class="hljs-literal">null</span>) {
          queue.<span class="hljs-property">firstCapturedEffect</span> = queue.<span class="hljs-property">lastCapturedEffect</span> = update;
        } <span class="hljs-keyword">else</span> {
          queue.<span class="hljs-property">lastCapturedEffect</span>.<span class="hljs-property">nextEffect</span> = update;
          queue.<span class="hljs-property">lastCapturedEffect</span> = update;
        }
      }
    }
    update = update.<span class="hljs-property">next</span>;
  }

  <span class="hljs-keyword">if</span> (newFirstUpdate === <span class="hljs-literal">null</span>) {
    queue.<span class="hljs-property">lastUpdate</span> = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">if</span> (newFirstCapturedUpdate === <span class="hljs-literal">null</span>) {
    queue.<span class="hljs-property">lastCapturedUpdate</span> = <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">else</span> {
    workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Callback</span>;
  }
  <span class="hljs-keyword">if</span> (newFirstUpdate === <span class="hljs-literal">null</span> &#x26;&#x26; newFirstCapturedUpdate === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// We processed every update, without skipping. That means the new base</span>
    <span class="hljs-comment">// state is the same as the result state.</span>
    newBaseState = resultState;
  }

  queue.<span class="hljs-property">baseState</span> = newBaseState;
  queue.<span class="hljs-property">firstUpdate</span> = newFirstUpdate;
  queue.<span class="hljs-property">firstCapturedUpdate</span> = newFirstCapturedUpdate;

  <span class="hljs-comment">// Set the remaining expiration time to be whatever is remaining in the queue.</span>
  <span class="hljs-comment">// This should be fine because the only two other things that contribute to</span>
  <span class="hljs-comment">// expiration time are props and context. We're already in the middle of the</span>
  <span class="hljs-comment">// begin phase by the time we start processing the queue, so we've already</span>
  <span class="hljs-comment">// dealt with the props. Context in components that specify</span>
  <span class="hljs-comment">// shouldComponentUpdate is tricky; but we'll have to account for</span>
  <span class="hljs-comment">// that regardless.</span>
  <span class="hljs-title function_">markUnprocessedUpdateTime</span>(newExpirationTime);
  workInProgress.<span class="hljs-property">expirationTime</span> = newExpirationTime;
  workInProgress.<span class="hljs-property">memoizedState</span> = resultState;

  <span class="hljs-keyword">if</span> (__DEV__) {
    currentlyProcessingQueue = <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h6 id="getstatefromupdate">getStateFromUpdate</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span>
<span class="hljs-keyword">function</span> getStateFromUpdate&#x3C;<span class="hljs-title class_">State</span>>(
  <span class="hljs-attr">workInProgress</span>: <span class="hljs-title class_">Fiber</span>,
  <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&#x3C;<span class="hljs-title class_">State</span>>,
  <span class="hljs-attr">update</span>: <span class="hljs-title class_">Update</span>&#x3C;<span class="hljs-title class_">State</span>>,
  <span class="hljs-attr">prevState</span>: <span class="hljs-title class_">State</span>,
  <span class="hljs-attr">nextProps</span>: any,
  <span class="hljs-attr">instance</span>: any,
): any {
  <span class="hljs-keyword">switch</span> (update.<span class="hljs-property">tag</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ReplaceState</span>: {
      <span class="hljs-keyword">const</span> payload = update.<span class="hljs-property">payload</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> payload === <span class="hljs-string">'function'</span>) {
        <span class="hljs-comment">// Updater function</span>
        <span class="hljs-keyword">if</span> (__DEV__) {
          <span class="hljs-title function_">enterDisallowedContextReadInDEV</span>();
          <span class="hljs-keyword">if</span> (
            debugRenderPhaseSideEffects ||
            (debugRenderPhaseSideEffectsForStrictMode &#x26;&#x26;
              workInProgress.<span class="hljs-property">mode</span> &#x26; <span class="hljs-title class_">StrictMode</span>)
          ) {
            payload.<span class="hljs-title function_">call</span>(instance, prevState, nextProps);
          }
        }
        <span class="hljs-keyword">const</span> nextState = payload.<span class="hljs-title function_">call</span>(instance, prevState, nextProps);
        <span class="hljs-keyword">if</span> (__DEV__) {
          <span class="hljs-title function_">exitDisallowedContextReadInDEV</span>();
        }
        <span class="hljs-keyword">return</span> nextState;
      }
      <span class="hljs-comment">// State object</span>
      <span class="hljs-keyword">return</span> payload;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">CaptureUpdate</span>: {
      workInProgress.<span class="hljs-property">effectTag</span> =
        (workInProgress.<span class="hljs-property">effectTag</span> &#x26; ~<span class="hljs-title class_">ShouldCapture</span>) | <span class="hljs-title class_">DidCapture</span>;
    }
    <span class="hljs-comment">// Intentional fallthrough</span>
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">UpdateState</span>: {
      <span class="hljs-keyword">const</span> payload = update.<span class="hljs-property">payload</span>;
      <span class="hljs-keyword">let</span> partialState;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> payload === <span class="hljs-string">'function'</span>) {
        <span class="hljs-comment">// Updater function</span>
        <span class="hljs-keyword">if</span> (__DEV__) {
          <span class="hljs-title function_">enterDisallowedContextReadInDEV</span>();
          <span class="hljs-keyword">if</span> (
            debugRenderPhaseSideEffects ||
            (debugRenderPhaseSideEffectsForStrictMode &#x26;&#x26;
              workInProgress.<span class="hljs-property">mode</span> &#x26; <span class="hljs-title class_">StrictMode</span>)
          ) {
            payload.<span class="hljs-title function_">call</span>(instance, prevState, nextProps);
          }
        }
        partialState = payload.<span class="hljs-title function_">call</span>(instance, prevState, nextProps);
        <span class="hljs-keyword">if</span> (__DEV__) {
          <span class="hljs-title function_">exitDisallowedContextReadInDEV</span>();
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Partial state object</span>
        partialState = payload;
      }
      <span class="hljs-keyword">if</span> (partialState === <span class="hljs-literal">null</span> || partialState === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-comment">// Null and undefined are treated as no-ops.</span>
        <span class="hljs-keyword">return</span> prevState;
      }
      <span class="hljs-comment">// Merge the partial state and the previous state.</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, prevState, partialState);
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForceUpdate</span>: {
      hasForceUpdate = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> prevState;
    }
  }
  <span class="hljs-keyword">return</span> prevState;
}
</code></pre>
<h5 id="reconcilechildren">reconcileChildren</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildren</span>(<span class="hljs-params">
  current: Fiber | <span class="hljs-literal">null</span>,
  workInProgress: Fiber,
  nextChildren: any,
  renderExpirationTime: ExpirationTime,
</span>) {
  <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// If this is a fresh new component that hasn't been rendered yet, we</span>
    <span class="hljs-comment">// won't update its child set by applying minimal side-effects. Instead,</span>
    <span class="hljs-comment">// we will add them all to the child before it gets rendered. That means</span>
    <span class="hljs-comment">// we can optimize this reconciliation pass by not tracking side-effects.</span>
    workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">mountChildFibers</span>(
      workInProgress,
      <span class="hljs-literal">null</span>,
      nextChildren,
      renderExpirationTime,
    );
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// If the current child is the same as the work in progress, it means that</span>
    <span class="hljs-comment">// we haven't yet started any work on these children. Therefore, we use</span>
    <span class="hljs-comment">// the clone algorithm to create a copy of all the current children.</span>

    <span class="hljs-comment">// If we had any progressed work already, that is invalid at this point so</span>
    <span class="hljs-comment">// let's throw it out.</span>
    workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">reconcileChildFibers</span>(
      workInProgress,
      current.<span class="hljs-property">child</span>,
      nextChildren,
      renderExpirationTime,
    );
  }
}
</code></pre>
<h5 id="reconcilechildfibers">reconcileChildFibers</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactChildFiber.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildFibers</span>(<span class="hljs-params">
    returnFiber: Fiber,
    currentFirstChild: Fiber | <span class="hljs-literal">null</span>,
    newChild: any,
    expirationTime: ExpirationTime,
  </span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-comment">// This function is not recursive.</span>
    <span class="hljs-comment">// If the top level item is an array, we treat it as a set of children,</span>
    <span class="hljs-comment">// not as a fragment. Nested arrays on the other hand will be treated as</span>
    <span class="hljs-comment">// fragment nodes. Recursion happens at the normal flow.</span>

    <span class="hljs-comment">// Handle top level unkeyed fragments as if they were arrays.</span>
    <span class="hljs-comment">// This leads to an ambiguity between &#x3C;>{[...]}&#x3C;/> and &#x3C;>...&#x3C;/>.</span>
    <span class="hljs-comment">// We treat the ambiguous cases above the same.</span>
    <span class="hljs-keyword">const</span> isUnkeyedTopLevelFragment =
      <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &#x26;&#x26;
      newChild !== <span class="hljs-literal">null</span> &#x26;&#x26;
      newChild.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span> &#x26;&#x26;
      newChild.<span class="hljs-property">key</span> === <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (isUnkeyedTopLevelFragment) {
      newChild = newChild.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;
    }

    <span class="hljs-comment">// Handle object types</span>
    <span class="hljs-keyword">const</span> isObject = <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &#x26;&#x26; newChild !== <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (isObject) {
      <span class="hljs-keyword">switch</span> (newChild.<span class="hljs-property">$$typeof</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ELEMENT_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">placeSingleChild</span>(
            <span class="hljs-title function_">reconcileSingleElement</span>(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime,
            ),
          );
        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PORTAL_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">placeSingleChild</span>(
            <span class="hljs-title function_">reconcileSinglePortal</span>(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime,
            ),
          );
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'number'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">placeSingleChild</span>(
        <span class="hljs-title function_">reconcileSingleTextNode</span>(
          returnFiber,
          currentFirstChild,
          <span class="hljs-string">''</span> + newChild,
          expirationTime,
        ),
      );
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray</span>(newChild)) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reconcileChildrenArray</span>(
        returnFiber,
        currentFirstChild,
        newChild,
        expirationTime,
      );
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIteratorFn</span>(newChild)) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reconcileChildrenIterator</span>(
        returnFiber,
        currentFirstChild,
        newChild,
        expirationTime,
      );
    }

    <span class="hljs-keyword">if</span> (isObject) {
      <span class="hljs-title function_">throwOnInvalidObjectType</span>(returnFiber, newChild);
    }

    <span class="hljs-keyword">if</span> (__DEV__) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'function'</span>) {
        <span class="hljs-title function_">warnOnFunctionType</span>();
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'undefined'</span> &#x26;&#x26; !isUnkeyedTopLevelFragment) {
      <span class="hljs-comment">// If the new child is undefined, and the return fiber is a composite</span>
      <span class="hljs-comment">// component, throw an error. If Fiber return types are disabled,</span>
      <span class="hljs-comment">// we already threw above.</span>
      <span class="hljs-keyword">switch</span> (returnFiber.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: {
          <span class="hljs-keyword">if</span> (__DEV__) {
            <span class="hljs-keyword">const</span> instance = returnFiber.<span class="hljs-property">stateNode</span>;
            <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">render</span>.<span class="hljs-property">_isMockFunction</span>) {
              <span class="hljs-comment">// We allow auto-mocks to proceed as if they're returning null.</span>
              <span class="hljs-keyword">break</span>;
            }
          }
        }
        <span class="hljs-comment">// Intentionally fall through to the next case, which handles both</span>
        <span class="hljs-comment">// functions and classes</span>
        <span class="hljs-comment">// eslint-disable-next-lined no-fallthrough</span>
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: {
          <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = returnFiber.<span class="hljs-property">type</span>;
          <span class="hljs-title function_">invariant</span>(
            <span class="hljs-literal">false</span>,
            <span class="hljs-string">'%s(...): Nothing was returned from render. This usually means a '</span> +
              <span class="hljs-string">'return statement is missing. Or, to render nothing, '</span> +
              <span class="hljs-string">'return null.'</span>,
            <span class="hljs-title class_">Component</span>.<span class="hljs-property">displayName</span> || <span class="hljs-title class_">Component</span>.<span class="hljs-property">name</span> || <span class="hljs-string">'Component'</span>,
          );
        }
      }
    }

    <span class="hljs-comment">// Remaining cases are all treated as empty.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);
  }
</code></pre>
<h5 id="reconcilesingleelement">reconcileSingleElement</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactChildFiber.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileSingleElement</span>(<span class="hljs-params">
    returnFiber: Fiber,
    currentFirstChild: Fiber | <span class="hljs-literal">null</span>,
    element: ReactElement,
    expirationTime: ExpirationTime,
  </span>): <span class="hljs-title class_">Fiber</span> {
    <span class="hljs-keyword">const</span> key = element.<span class="hljs-property">key</span>;
    <span class="hljs-keyword">let</span> child = currentFirstChild;
    <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If key === null and child.key === null, then this only applies to</span>
      <span class="hljs-comment">// the first item in the list.</span>
      <span class="hljs-keyword">if</span> (child.<span class="hljs-property">key</span> === key) {
        <span class="hljs-keyword">if</span> (
          child.<span class="hljs-property">tag</span> === <span class="hljs-title class_">Fragment</span>
            ? element.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span>
            : child.<span class="hljs-property">elementType</span> === element.<span class="hljs-property">type</span> ||
              <span class="hljs-comment">// Keep this check inline so it only runs on the false path:</span>
              (__DEV__
                ? <span class="hljs-title function_">isCompatibleFamilyForHotReloading</span>(child, element)
                : <span class="hljs-literal">false</span>)
        ) {
          <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="hljs-property">sibling</span>);
          <span class="hljs-keyword">const</span> existing = <span class="hljs-title function_">useFiber</span>(
            child,
            element.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span>
              ? element.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>
              : element.<span class="hljs-property">props</span>,
            expirationTime,
          );
          existing.<span class="hljs-property">ref</span> = <span class="hljs-title function_">coerceRef</span>(returnFiber, child, element);
          existing.<span class="hljs-property">return</span> = returnFiber;
          <span class="hljs-keyword">if</span> (__DEV__) {
            existing.<span class="hljs-property">_debugSource</span> = element.<span class="hljs-property">_source</span>;
            existing.<span class="hljs-property">_debugOwner</span> = element.<span class="hljs-property">_owner</span>;
          }
          <span class="hljs-keyword">return</span> existing;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child);
          <span class="hljs-keyword">break</span>;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">deleteChild</span>(returnFiber, child);
      }
      child = child.<span class="hljs-property">sibling</span>;
    }

    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span>) {
      <span class="hljs-keyword">const</span> created = <span class="hljs-title function_">createFiberFromFragment</span>(
        element.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>,
        returnFiber.<span class="hljs-property">mode</span>,
        expirationTime,
        element.<span class="hljs-property">key</span>,
      );
      created.<span class="hljs-property">return</span> = returnFiber;
      <span class="hljs-keyword">return</span> created;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> created = <span class="hljs-title function_">createFiberFromElement</span>(
        element,
        returnFiber.<span class="hljs-property">mode</span>,
        expirationTime,
      );
      created.<span class="hljs-property">ref</span> = <span class="hljs-title function_">coerceRef</span>(returnFiber, currentFirstChild, element);
      created.<span class="hljs-property">return</span> = returnFiber;
      <span class="hljs-keyword">return</span> created;
    }
  }
</code></pre>
<h6 id="createfiberfromelement">createFiberFromElement</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiber.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromElement</span>(<span class="hljs-params">
  element: ReactElement,
  mode: TypeOfMode,
  expirationTime: ExpirationTime,
</span>): <span class="hljs-title class_">Fiber</span> {
  <span class="hljs-keyword">let</span> owner = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (__DEV__) {
    owner = element.<span class="hljs-property">_owner</span>;
  }
  <span class="hljs-keyword">const</span> type = element.<span class="hljs-property">type</span>;
  <span class="hljs-keyword">const</span> key = element.<span class="hljs-property">key</span>;
  <span class="hljs-keyword">const</span> pendingProps = element.<span class="hljs-property">props</span>;
  <span class="hljs-keyword">const</span> fiber = <span class="hljs-title function_">createFiberFromTypeAndProps</span>(
    type,
    key,
    pendingProps,
    owner,
    mode,
    expirationTime,
  );
  <span class="hljs-keyword">if</span> (__DEV__) {
    fiber.<span class="hljs-property">_debugSource</span> = element.<span class="hljs-property">_source</span>;
    fiber.<span class="hljs-property">_debugOwner</span> = element.<span class="hljs-property">_owner</span>;
  }
  <span class="hljs-keyword">return</span> fiber;
}
</code></pre>
<h6 id=""></h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactChildFiber.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">coerceRef</span>(<span class="hljs-params">
  returnFiber: Fiber,
  current: Fiber | <span class="hljs-literal">null</span>,
  element: ReactElement,
</span>) {
  <span class="hljs-keyword">let</span> mixedRef = element.<span class="hljs-property">ref</span>;
  <span class="hljs-keyword">if</span> (
    mixedRef !== <span class="hljs-literal">null</span> &#x26;&#x26;
    <span class="hljs-keyword">typeof</span> mixedRef !== <span class="hljs-string">'function'</span> &#x26;&#x26;
    <span class="hljs-keyword">typeof</span> mixedRef !== <span class="hljs-string">'object'</span>
  ) {
    <span class="hljs-keyword">if</span> (__DEV__) {
      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Clean this up once we turn on the string ref warning for</span>
      <span class="hljs-comment">// everyone, because the strict mode case will no longer be relevant</span>
      <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">mode</span> &#x26; <span class="hljs-title class_">StrictMode</span> || warnAboutStringRefs) {
        <span class="hljs-keyword">const</span> componentName = <span class="hljs-title function_">getComponentName</span>(returnFiber.<span class="hljs-property">type</span>) || <span class="hljs-string">'Component'</span>;
        <span class="hljs-keyword">if</span> (!didWarnAboutStringRefs[componentName]) {
          <span class="hljs-keyword">if</span> (warnAboutStringRefs) {
            <span class="hljs-title function_">warningWithoutStack</span>(
              <span class="hljs-literal">false</span>,
              <span class="hljs-string">'Component "%s" contains the string ref "%s". Support for string refs '</span> +
                <span class="hljs-string">'will be removed in a future major release. We recommend using '</span> +
                <span class="hljs-string">'useRef() or createRef() instead. '</span> +
                <span class="hljs-string">'Learn more about using refs safely here: '</span> +
                <span class="hljs-string">'https://fb.me/react-strict-mode-string-ref%s'</span>,
              componentName,
              mixedRef,
              <span class="hljs-title function_">getStackByFiberInDevAndProd</span>(returnFiber),
            );
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">warningWithoutStack</span>(
              <span class="hljs-literal">false</span>,
              <span class="hljs-string">'A string ref, "%s", has been found within a strict mode tree. '</span> +
                <span class="hljs-string">'String refs are a source of potential bugs and should be avoided. '</span> +
                <span class="hljs-string">'We recommend using useRef() or createRef() instead. '</span> +
                <span class="hljs-string">'Learn more about using refs safely here: '</span> +
                <span class="hljs-string">'https://fb.me/react-strict-mode-string-ref%s'</span>,
              mixedRef,
              <span class="hljs-title function_">getStackByFiberInDevAndProd</span>(returnFiber),
            );
          }
          didWarnAboutStringRefs[componentName] = <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">_owner</span>) {
      <span class="hljs-keyword">const</span> <span class="hljs-attr">owner</span>: ?<span class="hljs-title class_">Fiber</span> = (element.<span class="hljs-property">_owner</span>: any);
      <span class="hljs-keyword">let</span> inst;
      <span class="hljs-keyword">if</span> (owner) {
        <span class="hljs-keyword">const</span> ownerFiber = ((<span class="hljs-attr">owner</span>: any): <span class="hljs-title class_">Fiber</span>);
        <span class="hljs-title function_">invariant</span>(
          ownerFiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>,
          <span class="hljs-string">'Function components cannot have refs. '</span> +
            <span class="hljs-string">'Did you mean to use React.forwardRef()?'</span>,
        );
        inst = ownerFiber.<span class="hljs-property">stateNode</span>;
      }
      <span class="hljs-title function_">invariant</span>(
        inst,
        <span class="hljs-string">'Missing owner for string ref %s. This error is likely caused by a '</span> +
          <span class="hljs-string">'bug in React. Please file an issue.'</span>,
        mixedRef,
      );
      <span class="hljs-keyword">const</span> stringRef = <span class="hljs-string">''</span> + mixedRef;
      <span class="hljs-comment">// Check if previous string ref matches new string ref</span>
      <span class="hljs-keyword">if</span> (
        current !== <span class="hljs-literal">null</span> &#x26;&#x26;
        current.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span> &#x26;&#x26;
        <span class="hljs-keyword">typeof</span> current.<span class="hljs-property">ref</span> === <span class="hljs-string">'function'</span> &#x26;&#x26;
        current.<span class="hljs-property">ref</span>.<span class="hljs-property">_stringRef</span> === stringRef
      ) {
        <span class="hljs-keyword">return</span> current.<span class="hljs-property">ref</span>;
      }
      <span class="hljs-keyword">const</span> ref = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
        <span class="hljs-keyword">let</span> refs = inst.<span class="hljs-property">refs</span>;
        <span class="hljs-keyword">if</span> (refs === emptyRefsObject) {
          <span class="hljs-comment">// This is a lazy pooled frozen object, so we need to initialize.</span>
          refs = inst.<span class="hljs-property">refs</span> = {};
        }
        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">delete</span> refs[stringRef];
        } <span class="hljs-keyword">else</span> {
          refs[stringRef] = value;
        }
      };
      ref.<span class="hljs-property">_stringRef</span> = stringRef;
      <span class="hljs-keyword">return</span> ref;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">invariant</span>(
        <span class="hljs-keyword">typeof</span> mixedRef === <span class="hljs-string">'string'</span>,
        <span class="hljs-string">'Expected ref to be a function, a string, an object returned by React.createRef(), or null.'</span>,
      );
      <span class="hljs-title function_">invariant</span>(
        element.<span class="hljs-property">_owner</span>,
        <span class="hljs-string">'Element ref was specified as a string (%s) but no owner was set. This could happen for one of'</span> +
          <span class="hljs-string">' the following reasons:\n'</span> +
          <span class="hljs-string">'1. You may be adding a ref to a function component\n'</span> +
          <span class="hljs-string">"2. You may be adding a ref to a component that was not created inside a component's render method\n"</span> +
          <span class="hljs-string">'3. You have multiple copies of React loaded\n'</span> +
          <span class="hljs-string">'See https://fb.me/react-refs-must-have-owner for more information.'</span>,
        mixedRef,
      );
    }
  }
  <span class="hljs-keyword">return</span> mixedRef;
}
</code></pre>
<h5 id="placesinglechild">placeSingleChild</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactChildFiber.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">placeSingleChild</span>(<span class="hljs-params">newFiber: Fiber</span>): <span class="hljs-title class_">Fiber</span> {
    <span class="hljs-comment">// This is simpler for the single child case. We only need to do a</span>
    <span class="hljs-comment">// placement for inserting new children.</span>
    <span class="hljs-keyword">if</span> (shouldTrackSideEffects &#x26;&#x26; newFiber.<span class="hljs-property">alternate</span> === <span class="hljs-literal">null</span>) {
      newFiber.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">Placement</span>;
    }
    <span class="hljs-keyword">return</span> newFiber;
  }
</code></pre>
<h5 id="completeunitofwork">completeUnitOfWork</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">completeUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-comment">// Attempt to complete the current unit of work, then move to the next</span>
  <span class="hljs-comment">// sibling. If there are no more siblings, return to the parent fiber.</span>
  workInProgress = unitOfWork;
  <span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// The current, flushed, state of this fiber is the alternate. Ideally</span>
    <span class="hljs-comment">// nothing should rely on this, but relying on it here means that we don't</span>
    <span class="hljs-comment">// need an additional field on the work in progress.</span>
    <span class="hljs-keyword">const</span> current = workInProgress.<span class="hljs-property">alternate</span>;
    <span class="hljs-keyword">const</span> returnFiber = workInProgress.<span class="hljs-property">return</span>;

    <span class="hljs-comment">// Check if the work completed or if something threw.</span>
    <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">effectTag</span> &#x26; <span class="hljs-title class_">Incomplete</span>) === <span class="hljs-title class_">NoEffect</span>) {
      <span class="hljs-title function_">setCurrentDebugFiberInDEV</span>(workInProgress);
      <span class="hljs-keyword">let</span> next;
      <span class="hljs-keyword">if</span> (
        !enableProfilerTimer ||
        (workInProgress.<span class="hljs-property">mode</span> &#x26; <span class="hljs-title class_">ProfileMode</span>) === <span class="hljs-title class_">NoMode</span>
      ) {
        next = <span class="hljs-title function_">completeWork</span>(current, workInProgress, renderExpirationTime);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">startProfilerTimer</span>(workInProgress);
        next = <span class="hljs-title function_">completeWork</span>(current, workInProgress, renderExpirationTime);
        <span class="hljs-comment">// Update render duration assuming we didn't error.</span>
        <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(workInProgress, <span class="hljs-literal">false</span>);
      }
      <span class="hljs-title function_">stopWorkTimer</span>(workInProgress);
      <span class="hljs-title function_">resetCurrentDebugFiberInDEV</span>();
      <span class="hljs-title function_">resetChildExpirationTime</span>(workInProgress);

      <span class="hljs-keyword">if</span> (next !== <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// Completing this fiber spawned new work. Work on that next.</span>
        <span class="hljs-keyword">return</span> next;
      }

      <span class="hljs-keyword">if</span> (
        returnFiber !== <span class="hljs-literal">null</span> &#x26;&#x26;
        <span class="hljs-comment">// Do not append effects to parents if a sibling failed to complete</span>
        (returnFiber.<span class="hljs-property">effectTag</span> &#x26; <span class="hljs-title class_">Incomplete</span>) === <span class="hljs-title class_">NoEffect</span>
      ) {
        <span class="hljs-comment">// Append all the effects of the subtree and this fiber onto the effect</span>
        <span class="hljs-comment">// list of the parent. The completion order of the children affects the</span>
        <span class="hljs-comment">// side-effect order.</span>
        <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">firstEffect</span> === <span class="hljs-literal">null</span>) {
          returnFiber.<span class="hljs-property">firstEffect</span> = workInProgress.<span class="hljs-property">firstEffect</span>;
        }
        <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
            returnFiber.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = workInProgress.<span class="hljs-property">firstEffect</span>;
          }
          returnFiber.<span class="hljs-property">lastEffect</span> = workInProgress.<span class="hljs-property">lastEffect</span>;
        }

        <span class="hljs-comment">// If this fiber had side-effects, we append it AFTER the children's</span>
        <span class="hljs-comment">// side-effects. We can perform certain side-effects earlier if needed,</span>
        <span class="hljs-comment">// by doing multiple passes over the effect list. We don't want to</span>
        <span class="hljs-comment">// schedule our own side-effect on our own list because if end up</span>
        <span class="hljs-comment">// reusing children we'll schedule this effect onto itself since we're</span>
        <span class="hljs-comment">// at the end.</span>
        <span class="hljs-keyword">const</span> effectTag = workInProgress.<span class="hljs-property">effectTag</span>;

        <span class="hljs-comment">// Skip both NoWork and PerformedWork tags when creating the effect</span>
        <span class="hljs-comment">// list. PerformedWork effect is read by React DevTools but shouldn't be</span>
        <span class="hljs-comment">// committed.</span>
        <span class="hljs-keyword">if</span> (effectTag > <span class="hljs-title class_">PerformedWork</span>) {
          <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
            returnFiber.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = workInProgress;
          } <span class="hljs-keyword">else</span> {
            returnFiber.<span class="hljs-property">firstEffect</span> = workInProgress;
          }
          returnFiber.<span class="hljs-property">lastEffect</span> = workInProgress;
        }
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// This fiber did not complete because something threw. Pop values off</span>
      <span class="hljs-comment">// the stack without entering the complete phase. If this is a boundary,</span>
      <span class="hljs-comment">// capture values if possible.</span>
      <span class="hljs-keyword">const</span> next = <span class="hljs-title function_">unwindWork</span>(workInProgress, renderExpirationTime);

      <span class="hljs-comment">// Because this fiber did not complete, don't reset its expiration time.</span>

      <span class="hljs-keyword">if</span> (
        enableProfilerTimer &#x26;&#x26;
        (workInProgress.<span class="hljs-property">mode</span> &#x26; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>
      ) {
        <span class="hljs-comment">// Record the render duration for the fiber that errored.</span>
        <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(workInProgress, <span class="hljs-literal">false</span>);

        <span class="hljs-comment">// Include the time spent working on failed children before continuing.</span>
        <span class="hljs-keyword">let</span> actualDuration = workInProgress.<span class="hljs-property">actualDuration</span>;
        <span class="hljs-keyword">let</span> child = workInProgress.<span class="hljs-property">child</span>;
        <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
          actualDuration += child.<span class="hljs-property">actualDuration</span>;
          child = child.<span class="hljs-property">sibling</span>;
        }
        workInProgress.<span class="hljs-property">actualDuration</span> = actualDuration;
      }

      <span class="hljs-keyword">if</span> (next !== <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// If completing this work spawned new work, do that next. We'll come</span>
        <span class="hljs-comment">// back here again.</span>
        <span class="hljs-comment">// Since we're restarting, remove anything that is not a host effect</span>
        <span class="hljs-comment">// from the effect tag.</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> The name stopFailedWorkTimer is misleading because Suspense</span>
        <span class="hljs-comment">// also captures and restarts.</span>
        <span class="hljs-title function_">stopFailedWorkTimer</span>(workInProgress);
        next.<span class="hljs-property">effectTag</span> &#x26;= <span class="hljs-title class_">HostEffectMask</span>;
        <span class="hljs-keyword">return</span> next;
      }
      <span class="hljs-title function_">stopWorkTimer</span>(workInProgress);

      <span class="hljs-keyword">if</span> (returnFiber !== <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// Mark the parent fiber as incomplete and clear its effect list.</span>
        returnFiber.<span class="hljs-property">firstEffect</span> = returnFiber.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;
        returnFiber.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Incomplete</span>;
      }
    }

    <span class="hljs-keyword">const</span> siblingFiber = workInProgress.<span class="hljs-property">sibling</span>;
    <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// If there is more work to do in this returnFiber, do that next.</span>
      <span class="hljs-keyword">return</span> siblingFiber;
    }
    <span class="hljs-comment">// Otherwise, return to the parent</span>
    workInProgress = returnFiber;
  } <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>);

  <span class="hljs-comment">// We've reached the root.</span>
  <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootIncomplete</span>) {
    workInProgressRootExitStatus = <span class="hljs-title class_">RootCompleted</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<h4 id="completework">completeWork</h4>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberCompleteWork.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">completeWork</span>(<span class="hljs-params">
  current: Fiber | <span class="hljs-literal">null</span>,
  workInProgress: Fiber,
  renderExpirationTime: ExpirationTime,
</span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;

  <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LazyComponent</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: {
      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isLegacyContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
        <span class="hljs-title function_">popLegacyContext</span>(workInProgress);
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>: {
      <span class="hljs-title function_">popHostContainer</span>(workInProgress);
      <span class="hljs-title function_">popTopLevelLegacyContextObject</span>(workInProgress);
      <span class="hljs-keyword">const</span> fiberRoot = (workInProgress.<span class="hljs-property">stateNode</span>: <span class="hljs-title class_">FiberRoot</span>);
      <span class="hljs-keyword">if</span> (fiberRoot.<span class="hljs-property">pendingContext</span>) {
        fiberRoot.<span class="hljs-property">context</span> = fiberRoot.<span class="hljs-property">pendingContext</span>;
        fiberRoot.<span class="hljs-property">pendingContext</span> = <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">child</span> === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// If we hydrated, pop so that we can delete any remaining children</span>
        <span class="hljs-comment">// that weren't hydrated.</span>
        <span class="hljs-keyword">let</span> wasHydrated = <span class="hljs-title function_">popHydrationState</span>(workInProgress);
        <span class="hljs-keyword">if</span> (wasHydrated) {
          <span class="hljs-comment">// If we hydrated, then we'll need to schedule an update for</span>
          <span class="hljs-comment">// the commit side-effects on the root.</span>
          <span class="hljs-title function_">markUpdate</span>(workInProgress);
        }
      }
      <span class="hljs-title function_">updateHostContainer</span>(workInProgress);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>: {
      <span class="hljs-title function_">popHostContext</span>(workInProgress);
      <span class="hljs-keyword">const</span> rootContainerInstance = <span class="hljs-title function_">getRootHostContainer</span>();
      <span class="hljs-keyword">const</span> type = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &#x26;&#x26; workInProgress.<span class="hljs-property">stateNode</span> != <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">updateHostComponent</span>(
          current,
          workInProgress,
          type,
          newProps,
          rootContainerInstance,
        );

        <span class="hljs-keyword">if</span> (enableFlareAPI) {
          <span class="hljs-keyword">const</span> prevListeners = current.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">listeners</span>;
          <span class="hljs-keyword">const</span> nextListeners = newProps.<span class="hljs-property">listeners</span>;
          <span class="hljs-keyword">if</span> (prevListeners !== nextListeners) {
            <span class="hljs-title function_">markUpdate</span>(workInProgress);
          }
        }

        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">ref</span> !== workInProgress.<span class="hljs-property">ref</span>) {
          <span class="hljs-title function_">markRef</span>(workInProgress);
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!newProps) {
          <span class="hljs-title function_">invariant</span>(
            workInProgress.<span class="hljs-property">stateNode</span> !== <span class="hljs-literal">null</span>,
            <span class="hljs-string">'We must have new props for new mounts. This error is likely '</span> +
              <span class="hljs-string">'caused by a bug in React. Please file an issue.'</span>,
          );
          <span class="hljs-comment">// This can happen when we abort work.</span>
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">const</span> currentHostContext = <span class="hljs-title function_">getHostContext</span>();
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Move createInstance to beginWork and keep it on a context</span>
        <span class="hljs-comment">// "stack" as the parent. Then append children as we go in beginWork</span>
        <span class="hljs-comment">// or completeWork depending on we want to add then top->down or</span>
        <span class="hljs-comment">// bottom->up. Top->down is faster in IE11.</span>
        <span class="hljs-keyword">let</span> wasHydrated = <span class="hljs-title function_">popHydrationState</span>(workInProgress);
        <span class="hljs-keyword">if</span> (wasHydrated) {
          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Move this and createInstance step into the beginPhase</span>
          <span class="hljs-comment">// to consolidate.</span>
          <span class="hljs-keyword">if</span> (
            <span class="hljs-title function_">prepareToHydrateHostInstance</span>(
              workInProgress,
              rootContainerInstance,
              currentHostContext,
            )
          ) {
            <span class="hljs-comment">// If changes to the hydrated node needs to be applied at the</span>
            <span class="hljs-comment">// commit-phase we mark this as such.</span>
            <span class="hljs-title function_">markUpdate</span>(workInProgress);
          }
          <span class="hljs-keyword">if</span> (enableFlareAPI) {
            <span class="hljs-keyword">const</span> listeners = newProps.<span class="hljs-property">listeners</span>;
            <span class="hljs-keyword">if</span> (listeners != <span class="hljs-literal">null</span>) {
              <span class="hljs-title function_">updateEventListeners</span>(
                listeners,
                workInProgress,
                rootContainerInstance,
              );
            }
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">let</span> instance = <span class="hljs-title function_">createInstance</span>(
            type,
            newProps,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );

          <span class="hljs-title function_">appendAllChildren</span>(instance, workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);

          <span class="hljs-comment">// This needs to be set before we mount Flare event listeners</span>
          workInProgress.<span class="hljs-property">stateNode</span> = instance;

          <span class="hljs-keyword">if</span> (enableFlareAPI) {
            <span class="hljs-keyword">const</span> listeners = newProps.<span class="hljs-property">listeners</span>;
            <span class="hljs-keyword">if</span> (listeners != <span class="hljs-literal">null</span>) {
              <span class="hljs-title function_">updateEventListeners</span>(
                listeners,
                workInProgress,
                rootContainerInstance,
              );
            }
          }

          <span class="hljs-comment">// Certain renderers require commit-time effects for initial mount.</span>
          <span class="hljs-comment">// (eg DOM renderer supports auto-focus for certain elements).</span>
          <span class="hljs-comment">// Make sure such renderers get scheduled for later work.</span>
          <span class="hljs-keyword">if</span> (
            <span class="hljs-title function_">finalizeInitialChildren</span>(
              instance,
              type,
              newProps,
              rootContainerInstance,
              currentHostContext,
            )
          ) {
            <span class="hljs-title function_">markUpdate</span>(workInProgress);
          }
        }

        <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span>) {
          <span class="hljs-comment">// If there is a ref on a host node we need to schedule a callback</span>
          <span class="hljs-title function_">markRef</span>(workInProgress);
        }
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>: {
      <span class="hljs-keyword">let</span> newText = newProps;
      <span class="hljs-keyword">if</span> (current &#x26;&#x26; workInProgress.<span class="hljs-property">stateNode</span> != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">const</span> oldText = current.<span class="hljs-property">memoizedProps</span>;
        <span class="hljs-comment">// If we have an alternate, that means this is an update and we need</span>
        <span class="hljs-comment">// to schedule a side-effect to do the updates.</span>
        <span class="hljs-title function_">updateHostText</span>(current, workInProgress, oldText, newText);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newText !== <span class="hljs-string">'string'</span>) {
          <span class="hljs-title function_">invariant</span>(
            workInProgress.<span class="hljs-property">stateNode</span> !== <span class="hljs-literal">null</span>,
            <span class="hljs-string">'We must have new props for new mounts. This error is likely '</span> +
              <span class="hljs-string">'caused by a bug in React. Please file an issue.'</span>,
          );
          <span class="hljs-comment">// This can happen when we abort work.</span>
        }
        <span class="hljs-keyword">const</span> rootContainerInstance = <span class="hljs-title function_">getRootHostContainer</span>();
        <span class="hljs-keyword">const</span> currentHostContext = <span class="hljs-title function_">getHostContext</span>();
        <span class="hljs-keyword">let</span> wasHydrated = <span class="hljs-title function_">popHydrationState</span>(workInProgress);
        <span class="hljs-keyword">if</span> (wasHydrated) {
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">prepareToHydrateHostTextInstance</span>(workInProgress)) {
            <span class="hljs-title function_">markUpdate</span>(workInProgress);
          }
        } <span class="hljs-keyword">else</span> {
          workInProgress.<span class="hljs-property">stateNode</span> = <span class="hljs-title function_">createTextInstance</span>(
            newText,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
        }
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>: {
      <span class="hljs-title function_">popSuspenseContext</span>(workInProgress);
      <span class="hljs-keyword">const</span> <span class="hljs-attr">nextState</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">SuspenseState</span> = workInProgress.<span class="hljs-property">memoizedState</span>;

      <span class="hljs-keyword">if</span> (enableSuspenseServerRenderer) {
        <span class="hljs-keyword">if</span> (nextState !== <span class="hljs-literal">null</span> &#x26;&#x26; nextState.<span class="hljs-property">dehydrated</span> !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">let</span> wasHydrated = <span class="hljs-title function_">popHydrationState</span>(workInProgress);
            <span class="hljs-title function_">invariant</span>(
              wasHydrated,
              <span class="hljs-string">'A dehydrated suspense component was completed without a hydrated node. '</span> +
                <span class="hljs-string">'This is probably a bug in React.'</span>,
            );
            <span class="hljs-title function_">prepareToHydrateHostSuspenseInstance</span>(workInProgress);
            <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
              <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">Never</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// We should never have been in a hydration state if we didn't have a current.</span>
            <span class="hljs-comment">// However, in some of those paths, we might have reentered a hydration state</span>
            <span class="hljs-comment">// and then we might be inside a hydration state. In that case, we'll need to</span>
            <span class="hljs-comment">// exit out of it.</span>
            <span class="hljs-title function_">resetHydrationState</span>();
            <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">effectTag</span> &#x26; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoEffect</span>) {
              <span class="hljs-comment">// This boundary did not suspend so it's now hydrated and unsuspended.</span>
              workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
            }
            <span class="hljs-comment">// If nothing suspended, we need to schedule an effect to mark this boundary</span>
            <span class="hljs-comment">// as having hydrated so events know that they're free be invoked.</span>
            <span class="hljs-comment">// It's also a signal to replay events and the suspense callback.</span>
            <span class="hljs-comment">// If something suspended, schedule an effect to attach retry listeners.</span>
            <span class="hljs-comment">// So we might as well always mark this.</span>
            workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Update</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }
        }
      }

      <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">effectTag</span> &#x26; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoEffect</span>) {
        <span class="hljs-comment">// Something suspended. Re-render with the fallback children.</span>
        workInProgress.<span class="hljs-property">expirationTime</span> = renderExpirationTime;
        <span class="hljs-comment">// Do not reset the effect list.</span>
        <span class="hljs-keyword">return</span> workInProgress;
      }

      <span class="hljs-keyword">const</span> nextDidTimeout = nextState !== <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">let</span> prevDidTimeout = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// In cases where we didn't find a suitable hydration boundary we never</span>
        <span class="hljs-comment">// put this in dehydrated mode, but we still need to pop the hydration</span>
        <span class="hljs-comment">// state since we might be inside the insertion tree.</span>
        <span class="hljs-title function_">popHydrationState</span>(workInProgress);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">const</span> <span class="hljs-attr">prevState</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">SuspenseState</span> = current.<span class="hljs-property">memoizedState</span>;
        prevDidTimeout = prevState !== <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (!nextDidTimeout &#x26;&#x26; prevState !== <span class="hljs-literal">null</span>) {
          <span class="hljs-comment">// We just switched from the fallback to the normal children.</span>
          <span class="hljs-comment">// Delete the fallback.</span>
          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Would it be better to store the fallback fragment on</span>
          <span class="hljs-comment">// the stateNode during the begin phase?</span>
          <span class="hljs-keyword">const</span> <span class="hljs-attr">currentFallbackChild</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> = (current.<span class="hljs-property">child</span>: any)
            .<span class="hljs-property">sibling</span>;
          <span class="hljs-keyword">if</span> (currentFallbackChild !== <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// Deletions go at the beginning of the return fiber's effect list</span>
            <span class="hljs-keyword">const</span> first = workInProgress.<span class="hljs-property">firstEffect</span>;
            <span class="hljs-keyword">if</span> (first !== <span class="hljs-literal">null</span>) {
              workInProgress.<span class="hljs-property">firstEffect</span> = currentFallbackChild;
              currentFallbackChild.<span class="hljs-property">nextEffect</span> = first;
            } <span class="hljs-keyword">else</span> {
              workInProgress.<span class="hljs-property">firstEffect</span> = workInProgress.<span class="hljs-property">lastEffect</span> = currentFallbackChild;
              currentFallbackChild.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
            }
            currentFallbackChild.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">Deletion</span>;
          }
        }
      }

      <span class="hljs-keyword">if</span> (nextDidTimeout &#x26;&#x26; !prevDidTimeout) {
        <span class="hljs-comment">// If this subtreee is running in batched mode we can suspend,</span>
        <span class="hljs-comment">// otherwise we won't suspend.</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This will still suspend a synchronous tree if anything</span>
        <span class="hljs-comment">// in the concurrent tree already suspended during this render.</span>
        <span class="hljs-comment">// This is a known bug.</span>
        <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &#x26; <span class="hljs-title class_">BatchedMode</span>) !== <span class="hljs-title class_">NoMode</span>) {
          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Move this back to throwException because this is too late</span>
          <span class="hljs-comment">// if this is a large tree which is common for initial loads. We</span>
          <span class="hljs-comment">// don't know if we should restart a render or not until we get</span>
          <span class="hljs-comment">// this marker, and this is too late.</span>
          <span class="hljs-comment">// If this render already had a ping or lower pri updates,</span>
          <span class="hljs-comment">// and this is the first time we know we're going to suspend we</span>
          <span class="hljs-comment">// should be able to immediately restart from within throwException.</span>
          <span class="hljs-keyword">const</span> hasInvisibleChildContext =
            current === <span class="hljs-literal">null</span> &#x26;&#x26;
            workInProgress.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">unstable_avoidThisFallback</span> !== <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">if</span> (
            hasInvisibleChildContext ||
            <span class="hljs-title function_">hasSuspenseContext</span>(
              suspenseStackCursor.<span class="hljs-property">current</span>,
              (<span class="hljs-title class_">InvisibleParentSuspenseContext</span>: <span class="hljs-title class_">SuspenseContext</span>),
            )
          ) {
            <span class="hljs-comment">// If this was in an invisible tree or a new render, then showing</span>
            <span class="hljs-comment">// this boundary is ok.</span>
            <span class="hljs-title function_">renderDidSuspend</span>();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Otherwise, we're going to have to hide content so we should</span>
            <span class="hljs-comment">// suspend for longer if possible.</span>
            <span class="hljs-title function_">renderDidSuspendDelayIfPossible</span>();
          }
        }
      }

      <span class="hljs-keyword">if</span> (supportsPersistence) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Only schedule updates if not prevDidTimeout.</span>
        <span class="hljs-keyword">if</span> (nextDidTimeout) {
          <span class="hljs-comment">// If this boundary just timed out, schedule an effect to attach a</span>
          <span class="hljs-comment">// retry listener to the proimse. This flag is also used to hide the</span>
          <span class="hljs-comment">// primary children.</span>
          workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Update</span>;
        }
      }
      <span class="hljs-keyword">if</span> (supportsMutation) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Only schedule updates if these values are non equal, i.e. it changed.</span>
        <span class="hljs-keyword">if</span> (nextDidTimeout || prevDidTimeout) {
          <span class="hljs-comment">// If this boundary just timed out, schedule an effect to attach a</span>
          <span class="hljs-comment">// retry listener to the proimse. This flag is also used to hide the</span>
          <span class="hljs-comment">// primary children. In mutation mode, we also need the flag to</span>
          <span class="hljs-comment">// *unhide* children that were previously hidden, so check if the</span>
          <span class="hljs-comment">// is currently timed out, too.</span>
          workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Update</span>;
        }
      }
      <span class="hljs-keyword">if</span> (
        enableSuspenseCallback &#x26;&#x26;
        workInProgress.<span class="hljs-property">updateQueue</span> !== <span class="hljs-literal">null</span> &#x26;&#x26;
        workInProgress.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">suspenseCallback</span> != <span class="hljs-literal">null</span>
      ) {
        <span class="hljs-comment">// Always notify the callback</span>
        workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Update</span>;
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Fragment</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Mode</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Profiler</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
      <span class="hljs-title function_">popHostContainer</span>(workInProgress);
      <span class="hljs-title function_">updateHostContainer</span>(workInProgress);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextProvider</span>:
      <span class="hljs-comment">// Pop provider fiber</span>
      <span class="hljs-title function_">popProvider</span>(workInProgress);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextConsumer</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IncompleteClassComponent</span>: {
      <span class="hljs-comment">// Same as class component case. I put it down here so that the tags are</span>
      <span class="hljs-comment">// sequential to ensure this switch is compiled to a jump table.</span>
      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isLegacyContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
        <span class="hljs-title function_">popLegacyContext</span>(workInProgress);
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>: {
      <span class="hljs-title function_">popSuspenseContext</span>(workInProgress);

      <span class="hljs-keyword">const</span> <span class="hljs-attr">renderState</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">SuspenseListRenderState</span> =
        workInProgress.<span class="hljs-property">memoizedState</span>;

      <span class="hljs-keyword">if</span> (renderState === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// We're running in the default, "independent" mode. We don't do anything</span>
        <span class="hljs-comment">// in this mode.</span>
        <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">let</span> didSuspendAlready =
        (workInProgress.<span class="hljs-property">effectTag</span> &#x26; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoEffect</span>;

      <span class="hljs-keyword">let</span> renderedTail = renderState.<span class="hljs-property">rendering</span>;
      <span class="hljs-keyword">if</span> (renderedTail === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// We just rendered the head.</span>
        <span class="hljs-keyword">if</span> (!didSuspendAlready) {
          <span class="hljs-comment">// This is the first pass. We need to figure out if anything is still</span>
          <span class="hljs-comment">// suspended in the rendered set.</span>

          <span class="hljs-comment">// If new content unsuspended, but there's still some content that</span>
          <span class="hljs-comment">// didn't. Then we need to do a second pass that forces everything</span>
          <span class="hljs-comment">// to keep showing their fallbacks.</span>

          <span class="hljs-comment">// We might be suspended if something in this render pass suspended, or</span>
          <span class="hljs-comment">// something in the previous committed pass suspended. Otherwise,</span>
          <span class="hljs-comment">// there's no chance so we can skip the expensive call to</span>
          <span class="hljs-comment">// findFirstSuspended.</span>
          <span class="hljs-keyword">let</span> cannotBeSuspended =
            <span class="hljs-title function_">renderHasNotSuspendedYet</span>() &#x26;&#x26;
            (current === <span class="hljs-literal">null</span> || (current.<span class="hljs-property">effectTag</span> &#x26; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoEffect</span>);
          <span class="hljs-keyword">if</span> (!cannotBeSuspended) {
            <span class="hljs-keyword">let</span> row = workInProgress.<span class="hljs-property">child</span>;
            <span class="hljs-keyword">while</span> (row !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">let</span> suspended = <span class="hljs-title function_">findFirstSuspended</span>(row);
              <span class="hljs-keyword">if</span> (suspended !== <span class="hljs-literal">null</span>) {
                didSuspendAlready = <span class="hljs-literal">true</span>;
                workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">DidCapture</span>;
                <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">false</span>);

                <span class="hljs-comment">// If this is a newly suspended tree, it might not get committed as</span>
                <span class="hljs-comment">// part of the second pass. In that case nothing will subscribe to</span>
                <span class="hljs-comment">// its thennables. Instead, we'll transfer its thennables to the</span>
                <span class="hljs-comment">// SuspenseList so that it can retry if they resolve.</span>
                <span class="hljs-comment">// There might be multiple of these in the list but since we're</span>
                <span class="hljs-comment">// going to wait for all of them anyway, it doesn't really matter</span>
                <span class="hljs-comment">// which ones gets to ping. In theory we could get clever and keep</span>
                <span class="hljs-comment">// track of how many dependencies remain but it gets tricky because</span>
                <span class="hljs-comment">// in the meantime, we can add/remove/change items and dependencies.</span>
                <span class="hljs-comment">// We might bail out of the loop before finding any but that</span>
                <span class="hljs-comment">// doesn't matter since that means that the other boundaries that</span>
                <span class="hljs-comment">// we did find already has their listeners attached.</span>
                <span class="hljs-keyword">let</span> newThennables = suspended.<span class="hljs-property">updateQueue</span>;
                <span class="hljs-keyword">if</span> (newThennables !== <span class="hljs-literal">null</span>) {
                  workInProgress.<span class="hljs-property">updateQueue</span> = newThennables;
                  workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Update</span>;
                }

                <span class="hljs-comment">// Rerender the whole list, but this time, we'll force fallbacks</span>
                <span class="hljs-comment">// to stay in place.</span>
                <span class="hljs-comment">// Reset the effect list before doing the second pass since that's now invalid.</span>
                workInProgress.<span class="hljs-property">firstEffect</span> = workInProgress.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;
                <span class="hljs-comment">// Reset the child fibers to their original state.</span>
                <span class="hljs-title function_">resetChildFibers</span>(workInProgress, renderExpirationTime);

                <span class="hljs-comment">// Set up the Suspense Context to force suspense and immediately</span>
                <span class="hljs-comment">// rerender the children.</span>
                <span class="hljs-title function_">pushSuspenseContext</span>(
                  workInProgress,
                  <span class="hljs-title function_">setShallowSuspenseContext</span>(
                    suspenseStackCursor.<span class="hljs-property">current</span>,
                    <span class="hljs-title class_">ForceSuspenseFallback</span>,
                  ),
                );
                <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
              }
              row = row.<span class="hljs-property">sibling</span>;
            }
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">false</span>);
        }
        <span class="hljs-comment">// Next we're going to render the tail.</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Append the rendered row to the child list.</span>
        <span class="hljs-keyword">if</span> (!didSuspendAlready) {
          <span class="hljs-keyword">let</span> suspended = <span class="hljs-title function_">findFirstSuspended</span>(renderedTail);
          <span class="hljs-keyword">if</span> (suspended !== <span class="hljs-literal">null</span>) {
            workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">DidCapture</span>;
            didSuspendAlready = <span class="hljs-literal">true</span>;
            <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">true</span>);
            <span class="hljs-comment">// This might have been modified.</span>
            <span class="hljs-keyword">if</span> (
              renderState.<span class="hljs-property">tail</span> === <span class="hljs-literal">null</span> &#x26;&#x26;
              renderState.<span class="hljs-property">tailMode</span> === <span class="hljs-string">'hidden'</span>
            ) {
              <span class="hljs-comment">// We need to delete the row we just rendered.</span>
              <span class="hljs-comment">// Ensure we transfer the update queue to the parent.</span>
              <span class="hljs-keyword">let</span> newThennables = suspended.<span class="hljs-property">updateQueue</span>;
              <span class="hljs-keyword">if</span> (newThennables !== <span class="hljs-literal">null</span>) {
                workInProgress.<span class="hljs-property">updateQueue</span> = newThennables;
                workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">Update</span>;
              }
              <span class="hljs-comment">// Reset the effect list to what it w as before we rendered this</span>
              <span class="hljs-comment">// child. The nested children have already appended themselves.</span>
              <span class="hljs-keyword">let</span> lastEffect = (workInProgress.<span class="hljs-property">lastEffect</span> =
                renderState.<span class="hljs-property">lastEffect</span>);
              <span class="hljs-comment">// Remove any effects that were appended after this point.</span>
              <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
                lastEffect.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
              }
              <span class="hljs-comment">// We're done.</span>
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
            <span class="hljs-title function_">now</span>() > renderState.<span class="hljs-property">tailExpiration</span> &#x26;&#x26;
            renderExpirationTime > <span class="hljs-title class_">Never</span>
          ) {
            <span class="hljs-comment">// We have now passed our CPU deadline and we'll just give up further</span>
            <span class="hljs-comment">// attempts to render the main content and only render fallbacks.</span>
            <span class="hljs-comment">// The assumption is that this is usually faster.</span>
            workInProgress.<span class="hljs-property">effectTag</span> |= <span class="hljs-title class_">DidCapture</span>;
            didSuspendAlready = <span class="hljs-literal">true</span>;

            <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">false</span>);

            <span class="hljs-comment">// Since nothing actually suspended, there will nothing to ping this</span>
            <span class="hljs-comment">// to get it started back up to attempt the next item. If we can show</span>
            <span class="hljs-comment">// them, then they really have the same priority as this render.</span>
            <span class="hljs-comment">// So we'll pick it back up the very next render pass once we've had</span>
            <span class="hljs-comment">// an opportunity to yield for paint.</span>

            <span class="hljs-keyword">const</span> nextPriority = renderExpirationTime - <span class="hljs-number">1</span>;
            workInProgress.<span class="hljs-property">expirationTime</span> = workInProgress.<span class="hljs-property">childExpirationTime</span> = nextPriority;
            <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
              <span class="hljs-title function_">markSpawnedWork</span>(nextPriority);
            }
          }
        }
        <span class="hljs-keyword">if</span> (renderState.<span class="hljs-property">isBackwards</span>) {
          <span class="hljs-comment">// The effect list of the backwards tail will have been added</span>
          <span class="hljs-comment">// to the end. This breaks the guarantee that life-cycles fire in</span>
          <span class="hljs-comment">// sibling order but that isn't a strong guarantee promised by React.</span>
          <span class="hljs-comment">// Especially since these might also just pop in during future commits.</span>
          <span class="hljs-comment">// Append to the beginning of the list.</span>
          renderedTail.<span class="hljs-property">sibling</span> = workInProgress.<span class="hljs-property">child</span>;
          workInProgress.<span class="hljs-property">child</span> = renderedTail;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">let</span> previousSibling = renderState.<span class="hljs-property">last</span>;
          <span class="hljs-keyword">if</span> (previousSibling !== <span class="hljs-literal">null</span>) {
            previousSibling.<span class="hljs-property">sibling</span> = renderedTail;
          } <span class="hljs-keyword">else</span> {
            workInProgress.<span class="hljs-property">child</span> = renderedTail;
          }
          renderState.<span class="hljs-property">last</span> = renderedTail;
        }
      }

      <span class="hljs-keyword">if</span> (renderState.<span class="hljs-property">tail</span> !== <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// We still have tail rows to render.</span>
        <span class="hljs-keyword">if</span> (renderState.<span class="hljs-property">tailExpiration</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-comment">// Heuristic for how long we're willing to spend rendering rows</span>
          <span class="hljs-comment">// until we just give up and show what we have so far.</span>
          <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TAIL_EXPIRATION_TIMEOUT_MS</span> = <span class="hljs-number">500</span>;
          renderState.<span class="hljs-property">tailExpiration</span> = <span class="hljs-title function_">now</span>() + <span class="hljs-variable constant_">TAIL_EXPIRATION_TIMEOUT_MS</span>;
        }
        <span class="hljs-comment">// Pop a row.</span>
        <span class="hljs-keyword">let</span> next = renderState.<span class="hljs-property">tail</span>;
        renderState.<span class="hljs-property">rendering</span> = next;
        renderState.<span class="hljs-property">tail</span> = next.<span class="hljs-property">sibling</span>;
        renderState.<span class="hljs-property">lastEffect</span> = workInProgress.<span class="hljs-property">lastEffect</span>;
        next.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;

        <span class="hljs-comment">// Restore the context.</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> We can probably just avoid popping it instead and only</span>
        <span class="hljs-comment">// setting it the first time we go from not suspended to suspended.</span>
        <span class="hljs-keyword">let</span> suspenseContext = suspenseStackCursor.<span class="hljs-property">current</span>;
        <span class="hljs-keyword">if</span> (didSuspendAlready) {
          suspenseContext = <span class="hljs-title function_">setShallowSuspenseContext</span>(
            suspenseContext,
            <span class="hljs-title class_">ForceSuspenseFallback</span>,
          );
        } <span class="hljs-keyword">else</span> {
          suspenseContext = <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseContext);
        }
        <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, suspenseContext);
        <span class="hljs-comment">// Do a pass over the next row.</span>
        <span class="hljs-keyword">return</span> next;
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FundamentalComponent</span>: {
      <span class="hljs-keyword">if</span> (enableFundamentalAPI) {
        <span class="hljs-keyword">const</span> fundamentalImpl = workInProgress.<span class="hljs-property">type</span>.<span class="hljs-property">impl</span>;
        <span class="hljs-keyword">let</span> <span class="hljs-attr">fundamentalInstance</span>: <span class="hljs-title class_">ReactFundamentalComponentInstance</span>&#x3C;
          any,
          any,
        > | <span class="hljs-literal">null</span> =
          workInProgress.<span class="hljs-property">stateNode</span>;

        <span class="hljs-keyword">if</span> (fundamentalInstance === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">const</span> getInitialState = fundamentalImpl.<span class="hljs-property">getInitialState</span>;
          <span class="hljs-keyword">let</span> fundamentalState;
          <span class="hljs-keyword">if</span> (getInitialState !== <span class="hljs-literal">undefined</span>) {
            fundamentalState = <span class="hljs-title function_">getInitialState</span>(newProps);
          }
          fundamentalInstance = workInProgress.<span class="hljs-property">stateNode</span> = <span class="hljs-title function_">createFundamentalStateInstance</span>(
            workInProgress,
            newProps,
            fundamentalImpl,
            fundamentalState || {},
          );
          <span class="hljs-keyword">const</span> instance = ((<span class="hljs-title function_">getFundamentalComponentInstance</span>(
            fundamentalInstance,
          ): any): <span class="hljs-title class_">Instance</span>);
          fundamentalInstance.<span class="hljs-property">instance</span> = instance;
          <span class="hljs-keyword">if</span> (fundamentalImpl.<span class="hljs-property">reconcileChildren</span> === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }
          <span class="hljs-title function_">appendAllChildren</span>(instance, workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
          <span class="hljs-title function_">mountFundamentalComponent</span>(fundamentalInstance);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// We fire update in commit phase</span>
          <span class="hljs-keyword">const</span> prevProps = fundamentalInstance.<span class="hljs-property">props</span>;
          fundamentalInstance.<span class="hljs-property">prevProps</span> = prevProps;
          fundamentalInstance.<span class="hljs-property">props</span> = newProps;
          fundamentalInstance.<span class="hljs-property">currentFiber</span> = workInProgress;
          <span class="hljs-keyword">if</span> (supportsPersistence) {
            <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">cloneFundamentalInstance</span>(fundamentalInstance);
            fundamentalInstance.<span class="hljs-property">instance</span> = instance;
            <span class="hljs-title function_">appendAllChildren</span>(instance, workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
          }
          <span class="hljs-keyword">const</span> shouldUpdate = <span class="hljs-title function_">shouldUpdateFundamentalComponent</span>(
            fundamentalInstance,
          );
          <span class="hljs-keyword">if</span> (shouldUpdate) {
            <span class="hljs-title function_">markUpdate</span>(workInProgress);
          }
        }
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>: {
      <span class="hljs-keyword">if</span> (enableScopeAPI) {
        <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">const</span> type = workInProgress.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">const</span> <span class="hljs-attr">scopeInstance</span>: <span class="hljs-title class_">ReactScopeInstance</span> = {
            <span class="hljs-attr">fiber</span>: workInProgress,
            <span class="hljs-attr">methods</span>: <span class="hljs-literal">null</span>,
          };
          workInProgress.<span class="hljs-property">stateNode</span> = scopeInstance;
          scopeInstance.<span class="hljs-property">methods</span> = <span class="hljs-title function_">createScopeMethods</span>(type, scopeInstance);
          <span class="hljs-keyword">if</span> (enableFlareAPI) {
            <span class="hljs-keyword">const</span> listeners = newProps.<span class="hljs-property">listeners</span>;
            <span class="hljs-keyword">if</span> (listeners != <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">const</span> rootContainerInstance = <span class="hljs-title function_">getRootHostContainer</span>();
              <span class="hljs-title function_">updateEventListeners</span>(
                listeners,
                workInProgress,
                rootContainerInstance,
              );
            }
          }
          <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span>) {
            <span class="hljs-title function_">markRef</span>(workInProgress);
            <span class="hljs-title function_">markUpdate</span>(workInProgress);
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (enableFlareAPI) {
            <span class="hljs-keyword">const</span> prevListeners = current.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">listeners</span>;
            <span class="hljs-keyword">const</span> nextListeners = newProps.<span class="hljs-property">listeners</span>;
            <span class="hljs-keyword">if</span> (
              prevListeners !== nextListeners ||
              workInProgress.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span>
            ) {
              <span class="hljs-title function_">markUpdate</span>(workInProgress);
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span>) {
              <span class="hljs-title function_">markUpdate</span>(workInProgress);
            }
          }
          <span class="hljs-keyword">if</span> (current.<span class="hljs-property">ref</span> !== workInProgress.<span class="hljs-property">ref</span>) {
            <span class="hljs-title function_">markRef</span>(workInProgress);
          }
        }
      }
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-attr">default</span>:
      <span class="hljs-title function_">invariant</span>(
        <span class="hljs-literal">false</span>,
        <span class="hljs-string">'Unknown unit of work tag (%s). This error is likely caused by a bug in '</span> +
          <span class="hljs-string">'React. Please file an issue.'</span>,
        workInProgress.<span class="hljs-property">tag</span>,
      );
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<h6 id="pophostcontainer">popHostContainer</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberHostContext.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">popHostContainer</span>(<span class="hljs-params">fiber: Fiber</span>) {
  <span class="hljs-title function_">pop</span>(contextStackCursor, fiber);
  <span class="hljs-title function_">pop</span>(contextFiberStackCursor, fiber);
  <span class="hljs-title function_">pop</span>(rootInstanceStackCursor, fiber);
}
</code></pre>
<h6 id="poptoplevellegacycontextobject">popTopLevelLegacyContextObject</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberContext.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">popTopLevelContextObject</span>(<span class="hljs-params">fiber: Fiber</span>): <span class="hljs-keyword">void</span> {
  <span class="hljs-keyword">if</span> (disableLegacyContext) {
    <span class="hljs-keyword">return</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">pop</span>(didPerformWorkStackCursor, fiber);
    <span class="hljs-title function_">pop</span>(contextStackCursor, fiber);
  }
}
</code></pre>
<h6 id="popdispatcher">popDispatcher</h6>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">popDispatcher</span>(<span class="hljs-params">prevDispatcher</span>) {
  <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = prevDispatcher;
}
</code></pre>
<h5 id="finishsyncrender">finishSyncRender</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">finishSyncRender</span>(<span class="hljs-params">root, exitStatus, expirationTime</span>) {
  <span class="hljs-keyword">if</span> (exitStatus === <span class="hljs-title class_">RootLocked</span>) {
    <span class="hljs-comment">// This root has a lock that prevents it from committing. Exit. If we</span>
    <span class="hljs-comment">// begin work on the root again, without any intervening updates, it</span>
    <span class="hljs-comment">// will finish without doing additional work.</span>
    <span class="hljs-title function_">markRootSuspendedAtTime</span>(root, expirationTime);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Set this to null to indicate there's no in-progress render.</span>
    workInProgressRoot = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (__DEV__) {
      <span class="hljs-keyword">if</span> (
        exitStatus === <span class="hljs-title class_">RootSuspended</span> ||
        exitStatus === <span class="hljs-title class_">RootSuspendedWithDelay</span>
      ) {
        <span class="hljs-title function_">flushSuspensePriorityWarningInDEV</span>();
      }
    }
    <span class="hljs-title function_">commitRoot</span>(root);
  }
}
</code></pre>
<h5 id="commitroot">commitRoot</h5>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// packages\react-reconciler\src\ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRoot</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">const</span> renderPriorityLevel = <span class="hljs-title function_">getCurrentPriorityLevel</span>();
  <span class="hljs-title function_">runWithPriority</span>(
    <span class="hljs-title class_">ImmediatePriority</span>,
    commitRootImpl.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root, renderPriorityLevel),
  );
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRootImpl</span>(<span class="hljs-params">root, renderPriorityLevel</span>) {
  <span class="hljs-title function_">flushPassiveEffects</span>();
  <span class="hljs-title function_">flushRenderPhaseStrictModeWarningsInDEV</span>();

  <span class="hljs-title function_">invariant</span>(
    (executionContext &#x26; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>,
    <span class="hljs-string">'Should not already be working.'</span>,
  );

  <span class="hljs-keyword">const</span> finishedWork = root.<span class="hljs-property">finishedWork</span>;
  <span class="hljs-keyword">const</span> expirationTime = root.<span class="hljs-property">finishedExpirationTime</span>;
  <span class="hljs-keyword">if</span> (finishedWork === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  root.<span class="hljs-property">finishedWork</span> = <span class="hljs-literal">null</span>;
  root.<span class="hljs-property">finishedExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-title function_">invariant</span>(
    finishedWork !== root.<span class="hljs-property">current</span>,
    <span class="hljs-string">'Cannot commit the same tree as before. This error is likely caused by '</span> +
      <span class="hljs-string">'a bug in React. Please file an issue.'</span>,
  );

  <span class="hljs-comment">// commitRoot never returns a continuation; it always finishes synchronously.</span>
  <span class="hljs-comment">// So we can clear these now to allow a new callback to be scheduled.</span>
  root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;
  root.<span class="hljs-property">callbackExpirationTime</span> = <span class="hljs-title class_">NoWork</span>;
  root.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoPriority</span>;
  root.<span class="hljs-property">nextKnownPendingLevel</span> = <span class="hljs-title class_">NoWork</span>;

  <span class="hljs-title function_">startCommitTimer</span>();

  <span class="hljs-comment">// Update the first and last pending times on this root. The new first</span>
  <span class="hljs-comment">// pending time is whatever is left on the root fiber.</span>
  <span class="hljs-keyword">const</span> remainingExpirationTimeBeforeCommit = <span class="hljs-title function_">getRemainingExpirationTime</span>(
    finishedWork,
  );
  <span class="hljs-title function_">markRootFinishedAtTime</span>(
    root,
    expirationTime,
    remainingExpirationTimeBeforeCommit,
  );

  <span class="hljs-keyword">if</span> (root === workInProgressRoot) {
    <span class="hljs-comment">// We can reset these now that they are finished.</span>
    workInProgressRoot = <span class="hljs-literal">null</span>;
    workInProgress = <span class="hljs-literal">null</span>;
    renderExpirationTime = <span class="hljs-title class_">NoWork</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// This indicates that the last root we worked on is not the same one that</span>
    <span class="hljs-comment">// we're committing now. This most commonly happens when a suspended root</span>
    <span class="hljs-comment">// times out.</span>
  }

  <span class="hljs-comment">// Get the list of effects.</span>
  <span class="hljs-keyword">let</span> firstEffect;
  <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">effectTag</span> > <span class="hljs-title class_">PerformedWork</span>) {
    <span class="hljs-comment">// A fiber's effect list consists only of its children, not itself. So if</span>
    <span class="hljs-comment">// the root has an effect, we need to add it to the end of the list. The</span>
    <span class="hljs-comment">// resulting list is the set that would belong to the root's parent, if it</span>
    <span class="hljs-comment">// had one; that is, all the effects in the tree including the root.</span>
    <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
      finishedWork.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = finishedWork;
      firstEffect = finishedWork.<span class="hljs-property">firstEffect</span>;
    } <span class="hljs-keyword">else</span> {
      firstEffect = finishedWork;
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// There is no effect on the root.</span>
    firstEffect = finishedWork.<span class="hljs-property">firstEffect</span>;
  }

  <span class="hljs-keyword">if</span> (firstEffect !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> prevExecutionContext = executionContext;
    executionContext |= <span class="hljs-title class_">CommitContext</span>;
    <span class="hljs-keyword">const</span> prevInteractions = <span class="hljs-title function_">pushInteractions</span>(root);

    <span class="hljs-comment">// Reset this to null before calling lifecycles</span>
    <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// The commit phase is broken into several sub-phases. We do a separate pass</span>
    <span class="hljs-comment">// of the effect list for each phase: all mutation effects come before all</span>
    <span class="hljs-comment">// layout effects, and so on.</span>

    <span class="hljs-comment">// The first phase a "before mutation" phase. We use this phase to read the</span>
    <span class="hljs-comment">// state of the host tree right before we mutate it. This is where</span>
    <span class="hljs-comment">// getSnapshotBeforeUpdate is called.</span>
    <span class="hljs-title function_">startCommitSnapshotEffectsTimer</span>();
    <span class="hljs-title function_">prepareForCommit</span>(root.<span class="hljs-property">containerInfo</span>);
    nextEffect = firstEffect;
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">if</span> (__DEV__) {
        <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, commitBeforeMutationEffects, <span class="hljs-literal">null</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
          <span class="hljs-title function_">invariant</span>(nextEffect !== <span class="hljs-literal">null</span>, <span class="hljs-string">'Should be working on an effect.'</span>);
          <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">clearCaughtError</span>();
          <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, error);
          nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">commitBeforeMutationEffects</span>();
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-title function_">invariant</span>(nextEffect !== <span class="hljs-literal">null</span>, <span class="hljs-string">'Should be working on an effect.'</span>);
          <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, error);
          nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
        }
      }
    } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);
    <span class="hljs-title function_">stopCommitSnapshotEffectsTimer</span>();

    <span class="hljs-keyword">if</span> (enableProfilerTimer) {
      <span class="hljs-comment">// Mark the current commit time to be shared by all Profilers in this</span>
      <span class="hljs-comment">// batch. This enables them to be grouped later.</span>
      <span class="hljs-title function_">recordCommitTime</span>();
    }

    <span class="hljs-comment">// The next phase is the mutation phase, where we mutate the host tree.</span>
    <span class="hljs-title function_">startCommitHostEffectsTimer</span>();
    nextEffect = firstEffect;
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">if</span> (__DEV__) {
        <span class="hljs-title function_">invokeGuardedCallback</span>(
          <span class="hljs-literal">null</span>,
          commitMutationEffects,
          <span class="hljs-literal">null</span>,
          root,
          renderPriorityLevel,
        );
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
          <span class="hljs-title function_">invariant</span>(nextEffect !== <span class="hljs-literal">null</span>, <span class="hljs-string">'Should be working on an effect.'</span>);
          <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">clearCaughtError</span>();
          <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, error);
          nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">commitMutationEffects</span>(root, renderPriorityLevel);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-title function_">invariant</span>(nextEffect !== <span class="hljs-literal">null</span>, <span class="hljs-string">'Should be working on an effect.'</span>);
          <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, error);
          nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
        }
      }
    } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);
    <span class="hljs-title function_">stopCommitHostEffectsTimer</span>();
    <span class="hljs-title function_">resetAfterCommit</span>(root.<span class="hljs-property">containerInfo</span>);

    <span class="hljs-comment">// The work-in-progress tree is now the current tree. This must come after</span>
    <span class="hljs-comment">// the mutation phase, so that the previous tree is still current during</span>
    <span class="hljs-comment">// componentWillUnmount, but before the layout phase, so that the finished</span>
    <span class="hljs-comment">// work is current during componentDidMount/Update.</span>
    root.<span class="hljs-property">current</span> = finishedWork;

    <span class="hljs-comment">// The next phase is the layout phase, where we call effects that read</span>
    <span class="hljs-comment">// the host tree after it's been mutated. The idiomatic use case for this is</span>
    <span class="hljs-comment">// layout, but class component lifecycles also fire here for legacy reasons.</span>
    <span class="hljs-title function_">startCommitLifeCyclesTimer</span>();
    nextEffect = firstEffect;
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">if</span> (__DEV__) {
        <span class="hljs-title function_">invokeGuardedCallback</span>(
          <span class="hljs-literal">null</span>,
          commitLayoutEffects,
          <span class="hljs-literal">null</span>,
          root,
          expirationTime,
        );
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
          <span class="hljs-title function_">invariant</span>(nextEffect !== <span class="hljs-literal">null</span>, <span class="hljs-string">'Should be working on an effect.'</span>);
          <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">clearCaughtError</span>();
          <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, error);
          nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">commitLayoutEffects</span>(root, expirationTime);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-title function_">invariant</span>(nextEffect !== <span class="hljs-literal">null</span>, <span class="hljs-string">'Should be working on an effect.'</span>);
          <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, error);
          nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
        }
      }
    } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);
    <span class="hljs-title function_">stopCommitLifeCyclesTimer</span>();

    nextEffect = <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// Tell Scheduler to yield at the end of the frame, so the browser has an</span>
    <span class="hljs-comment">// opportunity to paint.</span>
    <span class="hljs-title function_">requestPaint</span>();

    <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
      <span class="hljs-title function_">popInteractions</span>(((<span class="hljs-attr">prevInteractions</span>: any): <span class="hljs-title class_">Set</span>&#x3C;<span class="hljs-title class_">Interaction</span>>));
    }
    executionContext = prevExecutionContext;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// No effects.</span>
    root.<span class="hljs-property">current</span> = finishedWork;
    <span class="hljs-comment">// Measure these anyway so the flamegraph explicitly shows that there were</span>
    <span class="hljs-comment">// no effects.</span>
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Maybe there's a better way to report this.</span>
    <span class="hljs-title function_">startCommitSnapshotEffectsTimer</span>();
    <span class="hljs-title function_">stopCommitSnapshotEffectsTimer</span>();
    <span class="hljs-keyword">if</span> (enableProfilerTimer) {
      <span class="hljs-title function_">recordCommitTime</span>();
    }
    <span class="hljs-title function_">startCommitHostEffectsTimer</span>();
    <span class="hljs-title function_">stopCommitHostEffectsTimer</span>();
    <span class="hljs-title function_">startCommitLifeCyclesTimer</span>();
    <span class="hljs-title function_">stopCommitLifeCyclesTimer</span>();
  }

  <span class="hljs-title function_">stopCommitTimer</span>();

  <span class="hljs-keyword">const</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

  <span class="hljs-keyword">if</span> (rootDoesHavePassiveEffects) {
    <span class="hljs-comment">// This commit has passive effects. Stash a reference to them. But don't</span>
    <span class="hljs-comment">// schedule a callback until after flushing layout work.</span>
    rootDoesHavePassiveEffects = <span class="hljs-literal">false</span>;
    rootWithPendingPassiveEffects = root;
    pendingPassiveEffectsExpirationTime = expirationTime;
    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// We are done with the effect chain at this point so let's clear the</span>
    <span class="hljs-comment">// nextEffect pointers to assist with GC. If we have passive effects, we'll</span>
    <span class="hljs-comment">// clear this in flushPassiveEffects.</span>
    nextEffect = firstEffect;
    <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> nextNextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
      nextEffect.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
      nextEffect = nextNextEffect;
    }
  }

  <span class="hljs-comment">// Check if there's remaining work on this root</span>
  <span class="hljs-keyword">const</span> remainingExpirationTime = root.<span class="hljs-property">firstPendingTime</span>;
  <span class="hljs-keyword">if</span> (remainingExpirationTime !== <span class="hljs-title class_">NoWork</span>) {
    <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
      <span class="hljs-keyword">if</span> (spawnedWorkDuringRender !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">const</span> expirationTimes = spawnedWorkDuringRender;
        spawnedWorkDuringRender = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; expirationTimes.<span class="hljs-property">length</span>; i++) {
          <span class="hljs-title function_">scheduleInteractions</span>(
            root,
            expirationTimes[i],
            root.<span class="hljs-property">memoizedInteractions</span>,
          );
        }
      }
      <span class="hljs-title function_">schedulePendingInteractions</span>(root, remainingExpirationTime);
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// If there's no remaining work, we can clear the set of already failed</span>
    <span class="hljs-comment">// error boundaries.</span>
    legacyErrorBoundariesThatAlreadyFailed = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">if</span> (enableSchedulerTracing) {
    <span class="hljs-keyword">if</span> (!rootDidHavePassiveEffects) {
      <span class="hljs-comment">// If there are no passive effects, then we can complete the pending interactions.</span>
      <span class="hljs-comment">// Otherwise, we'll wait until after the passive effects are flushed.</span>
      <span class="hljs-comment">// Wait to do this until after remaining work has been scheduled,</span>
      <span class="hljs-comment">// so that we don't prematurely signal complete for interactions when there's e.g. hidden work.</span>
      <span class="hljs-title function_">finishPendingInteractions</span>(root, expirationTime);
    }
  }

  <span class="hljs-keyword">if</span> (remainingExpirationTime === <span class="hljs-title class_">Sync</span>) {
    <span class="hljs-comment">// Count the number of times the root synchronously re-renders without</span>
    <span class="hljs-comment">// finishing. If there are too many, it indicates an infinite update loop.</span>
    <span class="hljs-keyword">if</span> (root === rootWithNestedUpdates) {
      nestedUpdateCount++;
    } <span class="hljs-keyword">else</span> {
      nestedUpdateCount = <span class="hljs-number">0</span>;
      rootWithNestedUpdates = root;
    }
  } <span class="hljs-keyword">else</span> {
    nestedUpdateCount = <span class="hljs-number">0</span>;
  }

  <span class="hljs-title function_">onCommitRoot</span>(finishedWork.<span class="hljs-property">stateNode</span>, expirationTime);

  <span class="hljs-comment">// Always call this before exiting `commitRoot`, to ensure that any</span>
  <span class="hljs-comment">// additional work on this root is scheduled.</span>
  <span class="hljs-title function_">ensureRootIsScheduled</span>(root);

  <span class="hljs-keyword">if</span> (hasUncaughtError) {
    hasUncaughtError = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">const</span> error = firstUncaughtError;
    firstUncaughtError = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">throw</span> error;
  }

  <span class="hljs-keyword">if</span> ((executionContext &#x26; <span class="hljs-title class_">LegacyUnbatchedContext</span>) !== <span class="hljs-title class_">NoContext</span>) {
    <span class="hljs-comment">// This is a legacy edge case. We just committed the initial mount of</span>
    <span class="hljs-comment">// a ReactDOM.render-ed root inside of batchedUpdates. The commit fired</span>
    <span class="hljs-comment">// synchronously, but layout updates should be deferred until the end</span>
    <span class="hljs-comment">// of the batch.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// If layout work was scheduled, flush it now.</span>
  <span class="hljs-title function_">flushSyncCallbackQueue</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>2:["$","div",null,{"children":[["$","h1",null,{"className":"text-3xl font-semibold","children":"react源码阅读"}],["$","div",null,{"className":"fixed right-12 bottom-20 ","children":["$","$Le",null,{"toc":"$f"}]}],["$","div",null,{"className":"page_content__nM6Lc","dangerouslySetInnerHTML":{"__html":"$10"}}]]}]
d:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"文章 | react源码阅读"}],["$","meta","3",{"name":"description","content":"新宸悦雨 博客 网站 个人网站"}],["$","meta","4",{"name":"google-site-verification","content":"LiZ4kQwHGTLadwCnDnrXngpwNqoQjmFOCOVTtr_PWVo"}],["$","link","5",{"rel":"icon","href":"/icon.svg?d2cf70afa15ddfd8","type":"image/svg+xml","sizes":"any"}]]
1:null
